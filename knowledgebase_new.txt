

// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/assets/svg/index.ts

export { default as close } from './close.svg?react';
export { default as closeV2 } from './closeV2.svg?react';
export { default as largeArrowLeft } from './large-arrow-left.svg?react';
export { default as microphone } from './microphone.svg?react';
export { default as minus } from './minus.svg?react';
export { default as smallArrowUp } from './small-arrow-up.svg?react';
export { default as sound } from './sound.svg?react';
export { default as soundOff } from './sound-off.svg?react';
export { default as stop } from './stop.svg?react';
export { default as thumbsUp } from './thumbs-up.svg?react';
export { default as topCaret } from './top-caret.svg?react';
export { default as plusCircle } from './plus-circle.svg?react';



// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/common/index.ts

export * from './utils';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/common/utils.ts

export { isObject } from 'remeda';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/AssistantInfo/AssistantInfo.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Chat from '@/components/Chat';
import { VF_ICON } from '@/fixtures';

import type { AssistantInfoProps } from '.';
import AssistantInfo from '.';

type Story = StoryObj<typeof AssistantInfo>;

const meta: Meta<typeof AssistantInfo> = {
  title: 'Components/Chat/AssistantInfo',
  component: AssistantInfo,
  args: {
    title: 'Assistant Name',
    description: "Voiceflow's virtual assistant is here to help.",
    avatar: VF_ICON,
  },
};

export default meta;

export const Default: Story = {
  render: (args: AssistantInfoProps) => (
    <Chat.Container>
      <AssistantInfo {...args} />
    </Chat.Container>
  ),
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/AssistantInfo/index.tsx

import Avatar from '@/components/Avatar';

import { Container, Description, Title } from './styled';

export interface AssistantInfoProps {
  /**
   * The title of the assistant.
   */
  title: string;

  /**
   * A short description of the assistant to help frame the conversation.
   */
  description: string;

  /**
   * An image URL that identifies the assistant, such as a brand icon.
   */
  avatar: string;
}

const AssistantInfo: React.FC<AssistantInfoProps> = ({ title, description, avatar }) => (
  <Container>
    <Avatar size="large" avatar={avatar} />
    <Title>{title}</Title>
    <Description>{description}</Description>
  </Container>
);

/**
 * This component displays introductory information about the assistant.
 * It will act as a placeholder before the conversation has started.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-chat-assistantinfo--default}
 */
export default Object.assign(AssistantInfo, {
  Container,
  Title,
  Description,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/AssistantInfo/styled.ts

import Avatar from '@/components/Avatar';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';
import { textOverflowStyles } from '@/styles/fragments';

const tag = tagFactory(ClassName.ASSISTANT_INFO);

export const Title = styled(tag('h2', 'title'), {
  ...textOverflowStyles,
  width: '100%',
  margin: 0,
  typo: { size: 20, weight: '$2', height: '$3' },
  color: '$black',
});

export const Description = styled(tag('p', 'description'), {
  display: '-webkit-box',
  margin: 0,
  typo: {},
  color: '$darkGrey',
  '-webkit-line-clamp': 2,
  '-webkit-box-orient': 'vertical',
  overflow: 'hidden',
  wordBreak: 'break-word',
});

export const Container = styled(tag('div'), {
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  padding: '48px 32px',
  textAlign: 'center',

  [`& ${Avatar.Container}`]: {
    marginBottom: '$4',
  },

  [`& ${Title}`]: {
    marginBottom: 8,
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Avatar/Avatar.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import { VF_ICON } from '@/fixtures';

import Avatar from '.';

type Story = StoryObj<typeof Avatar>;

const meta: Meta<typeof Avatar> = {
  title: 'Core/Avatar',
  component: Avatar,
  argTypes: {
    size: {
      options: ['small', 'large'],
      control: { type: 'radio' },
      defaultValue: 'small',
    },
  },
  args: {
    avatar: VF_ICON,
  },
};
export default meta;

export const Small: Story = {
  args: {
    size: 'small',
  },
};

export const Large: Story = {
  args: {
    size: 'large',
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Avatar/index.tsx

import type { VariantProp } from '@/types';

import { AvatarContainer } from './styled';

export interface AvatarProps extends React.ComponentProps<typeof AvatarContainer> {
  /**
   * An image URL which will be rendered as the background.
   */
  avatar: string;

  /**
   * Pre-defined size variants.
   *
   * @default 'small'
   */
  size?: VariantProp<typeof AvatarContainer, 'size'>;
}

const Avatar: React.FC<AvatarProps> = ({ avatar, ...props }) => (
  <AvatarContainer {...props} css={{ backgroundImage: `url(${avatar})`, ...props.css }} />
);

/**
 * Displays an image in a circular frame.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/core-avatar--small}
 */
export default Object.assign(Avatar, {
  Container: AvatarContainer,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Avatar/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.AVATAR);

export const AvatarContainer = styled(tag('div'), {
  flexShrink: 0,
  borderRadius: '$round',
  backgroundColor: '$lightGrey',
  backgroundPosition: 'center',
  backgroundRepeat: 'no-repeat',
  backgroundSize: 'cover',

  variants: {
    size: {
      small: {
        height: 26,
        width: 26,
      },

      large: {
        height: '$xxl',
        width: '$xxl',
        boxSizing: 'border-box',
        boxShadow: '0 4px 16px 0 $shadow4, 0 0 0 1px $shadow2',
      },
    },
  },
  defaultVariants: {
    size: 'small',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Bubble/Bubble.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import * as SVGs from '@/assets/svg';

import Bubble from '.';

type Story = StoryObj<typeof Bubble>;

const meta: Meta<typeof Bubble> = {
  title: 'Core/Bubble',
  component: Bubble,
  args: {
    color: '#fff',
  },
  argTypes: {
    size: {
      options: ['small', 'large'],
      control: { type: 'radio' },
      defaultValue: 'large',
    },
    svg: {
      options: Object.keys(SVGs).filter((svg) => svg !== 'topCaret'),
      control: { type: 'radio' },
    },
  },
};
export default meta;

export const Small: Story = {
  args: {
    size: 'small',
    svg: 'smallArrowUp',
  },
};

export const Large: Story = {
  args: {
    size: 'large',
    svg: 'close',
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Bubble/index.tsx

import type { IconProps } from '@/components/Icon';
import Icon from '@/components/Icon';
import type { VariantProp } from '@/types';

import { Container } from './styled';

export interface BubbleProps extends React.ComponentProps<typeof Container> {
  /**
   * The name of the SVG icon to be rendered or a React component.
   *
   * @see {@link https://github.com/voiceflow/react-chat/tree/master/packages/react-chat/src/assets/svg the available icons}
   */
  svg: IconProps['svg'];

  /**
   * Pre-defined size variants.
   *
   * @default 'large'
   */
  size?: VariantProp<typeof Container, 'size'>;
}

const Bubble: React.FC<BubbleProps> = ({ svg, color, ...props }) => (
  <Container {...props}>
    <Icon svg={svg} css={{ color, ...props.css }} />
  </Container>
);

/**
 * Call-to-action button with an icon.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/core-bubble--small}
 */
export default Object.assign(Bubble, {
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Bubble/styled.ts

import Button from '@/components/Button';
import Icon from '@/components/Icon';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.BUBBLE);

export const Container = styled(tag(Button.Reset), {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  borderRadius: '$round',
  backgroundColor: '$primary',
  trans: ['background-color', 'box-shadow'],

  '&:hover': {
    backgroundColor: '$darkPrimary',
  },

  variants: {
    size: {
      small: {
        height: '$xs',
        width: '$xs',

        [`& ${Icon.Frame}`]: {
          width: '$xxs',
          height: '$xxs',
        },
      },

      large: {
        height: '$xl',
        width: '$xl',
        border: '1px solid $shadow4',
        boxShadow: '0 1px 6px $shadow6, 0 2px 24px $shadow8',

        [`& ${Icon.Frame}`]: {
          width: '$sm',
          height: '$sm',
        },
      },
    },
  },
  defaultVariants: {
    size: 'large',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Button/Button.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Button from '.';

type Story = StoryObj<typeof Button>;
const meta: Meta<typeof Button> = {
  title: 'Core/Button',
  component: Button,
  argTypes: {
    variant: {
      options: Object.values(Button.Variant),
      control: { type: 'radio' },
      defaultValue: Button.Variant.PRIMARY,
    },
    type: {
      if: { arg: 'variant', eq: Button.Variant.PRIMARY },
      options: ['info', 'warn', 'subtle'],
      control: { type: 'radio' },
      defaultValue: 'info',
    },
  },
  args: {
    children: 'Button Label',
  },
};

export default meta;

export const PrimaryInfo: Story = {
  args: {
    variant: Button.Variant.PRIMARY,
    type: 'info',
  },
};

export const PrimaryWarn: Story = {
  args: {
    variant: Button.Variant.PRIMARY,
    type: 'warn',
  },
};

export const PrimarySubtle: Story = {
  args: {
    variant: Button.Variant.PRIMARY,
    type: 'subtle',
  },
};

export const Secondary: Story = {
  args: {
    variant: Button.Variant.SECONDARY,
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Button/Button.test.tsx

import { render, screen } from '@testing-library/react';
import { describe, expect, it } from 'vitest';

import Button from '.';

describe('Button', () => {
  it('should render a button with a label', async () => {
    const label = 'Button Label';

    render(<Button>{label}</Button>);

    expect(screen.getByText(label)).toBeInTheDocument();
    expect(screen.getByRole('button')).toBeInTheDocument();
  });
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Button/Primary.ts

import { styled } from '@/styles';

import { ButtonVariant } from './constants';
import { Container, tag } from './styled';

export const PrimaryButton = styled(tag(Container, ButtonVariant.PRIMARY), {
  minHeight: '$md',
  color: '$white',
  trans: ['background-color'],
  padding: '10px 14px',
  boxSizing: 'border-box',
  whiteSpace: 'break-spaces',

  variants: {
    type: {
      info: {
        backgroundColor: '$primary',

        '&:hover': {
          backgroundColor: '$darkPrimary',
        },
      },

      warn: {
        backgroundColor: '$warn',

        '&:hover': {
          backgroundColor: '$darkWarn',
        },
      },

      subtle: {
        color: '$black',
        backgroundColor: 'inherit',
        trans: ['color'],

        '&:hover': {
          color: '#000',
        },
      },
    },
  },
  defaultVariants: {
    type: 'info',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Button/Secondary.ts

import { styled } from '@/styles';

import { ButtonVariant } from './constants';
import { Container, tag } from './styled';

export const SecondaryButton = styled(tag(Container, ButtonVariant.SECONDARY), {
  height: '$sm',
  border: '1px solid $fadedPrimary',
  color: '$primary',
  backgroundColor: '$white',
  boxShadow: '0 1px 2px $shadow2',
  trans: ['border-color'],

  '&:hover': {
    borderColor: '$primary',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Button/constants.ts

export enum ButtonVariant {
  PRIMARY = 'primary',
  SECONDARY = 'secondary',
}


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Button/index.ts

import { bindVariants } from '@/utils/variants';

import { ButtonVariant } from './constants';
import { PrimaryButton } from './Primary';
import { SecondaryButton } from './Secondary';
import { Container, Reset } from './styled';

const VARIANTS = {
  [ButtonVariant.PRIMARY]: PrimaryButton,
  [ButtonVariant.SECONDARY]: SecondaryButton,
};

const Button = bindVariants(VARIANTS, ButtonVariant.PRIMARY);

/**
 * A button with a label.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/core-button--primary-info}
 */
export default Object.assign(Button, {
  Variant: ButtonVariant,

  Reset,
  Container,
  Primary: PrimaryButton,
  Secondary: SecondaryButton,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Button/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

export const tag = tagFactory(ClassName.BUTTON);

export const Reset = styled('button', {
  border: 0,
  padding: 0,

  '&:focus': {
    outline: 0,
  },

  '&:hover': {
    cursor: 'pointer',
  },
});

export const Container = styled(tag(Reset), {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  padding: '0 14px',
  borderRadius: '$1',
  typo: { weight: '$2' },
  whiteSpace: 'nowrap',
  overflowWrap: 'anywhere',
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Card/Card.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import { MOCK_IMAGE } from '@/fixtures';

import Card from '.';

type Story = StoryObj<typeof Card>;

const meta: Meta<typeof Card> = {
  title: 'Components/Card',
  component: Card,
  args: {
    title: 'Card Header',
    image: '',
    description:
      'Lorem ipsum dolor sit amet consectetur, adipisicing elit. Culpa et aliquam sunt necessitatibus molestiae amet ipsum ut.',
    actions: [],
  },
};
export default meta;

export const Simple: Story = {};

export const WithImage: Story = {
  args: {
    image: MOCK_IMAGE,
  },
};

export const Actionable: Story = {
  args: {
    ...WithImage.args,
    actions: [
      { request: {} as any, name: 'First Button' },
      { request: {} as any, name: 'Second Button' },
      { request: {} as any, name: 'Third Button' },
    ],
  },
};

export const WithLongLabels: Story = {
  args: {
    ...WithImage.args,
    actions: [
      { request: {} as any, name: 'First Button with a very long long long wrapping label' },
      { request: {} as any, name: 'Second Button with a shorter text' },
      { request: {} as any, name: 'Third button, also with a shorter text' },
    ],
  },
};

export const WithLongTitle: Story = {
  args: {
    ...WithImage.args,
    title: 'Long card title to wrap inside the card. Some more text to test the growth of card.',
    actions: [{ request: {} as any, name: 'First Button' }],
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Card/index.tsx

import { useContext, useMemo } from 'react';

import Button from '@/components/Button';
import Image from '@/components/Image';
import { RuntimeStateAPIContext } from '@/contexts';

import { Container, Content, Description, Header, Link } from './styled';
import type { CardProps } from './types';
import { isValidHttpUrl } from './utils';

export type { CardProps } from './types';

const Card: React.FC<CardProps> = ({ title, description, image, actions = [] }) => {
  const runtime = useContext(RuntimeStateAPIContext);
  const isLink = isValidHttpUrl(description);

  const buttons = useMemo(() => actions.filter(({ name }) => !!name), [actions]);

  return (
    <Container>
      {!!image && <Image image={image} />}
      <Content>
        {!!title && <Header>{title}</Header>}
        {!!description &&
          (isLink ? (
            <Link rel="noopener noreferrer" href={description} target="_blank">
              {description}
            </Link>
          ) : (
            <Description>{description}</Description>
          ))}
        {buttons.map(({ request, name }, index) => (
          <Button onClick={() => runtime.interact(request, name)} key={index}>
            {name}
          </Button>
        ))}
      </Content>
    </Container>
  );
};

/**
 * A titled card with content and optional controls.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-card--simple}
 */
export default Object.assign(Card, {
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Card/styled.ts

import Button from '@/components/Button';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

export const CARD_WIDTH = 246;

const tag = tagFactory(ClassName.CARD);

export const Container = styled(tag('section'), {
  display: 'inline-flex',
  flexDirection: 'column',
  width: CARD_WIDTH,
  border: '1px solid #f1f1f1',
  borderRadius: '$2',
  boxSizing: 'content-box',
  overflow: 'hidden',
  backgroundColor: '$lightGrey',

  [`& ${Button.Container}`]: {
    width: '100%',
    color: '$primary',
    backgroundColor: '$white',
    boxShadow: '0 5px 8px -8px $shadow12, 0 2px 4px -3px $shadow12, 0 0 0 1px $shadow3, 0 1px 3px 1px $shadow1',
    marginBottom: '$2',
    trans: ['color', 'box-shadow'],

    '&:hover': {
      color: '$darkPrimary',
      backgroundColor: '$white',
      boxShadow: '0 5px 8px -8px $shadow12, 0 2px 4px -3px $shadow12, 0 0 0 1px $shadow4, 0 1px 4px 1px $shadow4',
    },

    '&:first-of-type': {
      marginTop: '$3',
    },

    '&:last-of-type': {
      marginBottom: 0,
    },
  },
});

export const Content = styled(tag('main', 'content'), {
  padding: '$3',
});

export const Header = styled(tag('h3', 'header'), {
  margin: '0 0 $1 0',
  typo: { weight: '$2' },
  color: '$black',
  wordBreak: 'break-word',
  maxWidth: '100%',
  whiteSpace: 'break-spaces',
});

export const Description = styled(tag('p', 'description'), {
  margin: 0,
  typo: { size: '$1' },
  color: '$darkGrey',
  whiteSpace: 'normal',
  wordBreak: 'break-word',
});

export const Link = styled(tag('a', 'link'), {
  margin: 0,
  typo: { size: '$1' },
  whiteSpace: 'normal',
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  color: 'rgb(93, 157, 245)',
  textDecoration: 'underline',
  pointerEvents: 'all',
  wordBreak: 'break-all',
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Card/types.ts

import type { RuntimeAction } from '@voiceflow/sdk-runtime';

import type { Link } from './styled';

export interface CardActionProps {
  /**
   * The label that will appear on the button.
   */
  name: string;

  /**
   * the request that will be sent by the runtime when the button is clicked.
   */
  request: RuntimeAction;
}

export interface CardProps {
  /**
   * The title of the card.
   */
  title: string;

  /**
   * Text content of the card.
   * If the string is a valid URL it will be rendered in a {@link Link}.
   */
  description: string;

  /**
   * An image URL that will render at the top of the card if provided.
   */
  image?: string | undefined | null;

  /**
   * A list of actions that will appear as button controls at the bottom of the card.
   */
  actions?: CardActionProps[] | undefined;
}


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Card/utils.ts

export const isValidHttpUrl = (value: string) => {
  let url;

  try {
    url = new URL(value);
  } catch (_) {
    return false;
  }
  return url.protocol === 'http:' || url.protocol === 'https:';
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Carousel/Carousel.story.tsx

import type { Meta, StoryObj } from '@storybook/react';
import { useRef } from 'react';

import Avatar from '@/components/Avatar';
import Chat from '@/components/Chat';
import SystemResponse from '@/components/SystemResponse';
import { MOCK_IMAGE, VF_ICON } from '@/fixtures';
import { ChatWidget } from '@/views';

import Carousel from '.';

const meta: Meta<typeof Carousel> = {
  component: Carousel,
  title: 'Components/Carousel',
};
type Story = StoryObj<typeof Carousel>;

export default meta;

const IMAGE = MOCK_IMAGE;
const FIRST_CARD = {
  title: 'First Card',
  description: 'Lorem ipsum dolor sit amet',
  image: IMAGE,
  actions: [
    { request: {} as any, name: 'First Button' },
    { request: {} as any, name: 'Second Button' },
    { request: {} as any, name: 'Third Button' },
  ],
};

const MULTIPLE_CARDS = [
  FIRST_CARD,
  {
    title: 'Second Card',
    description:
      'Lorem ipsum dolor sit amet consectetur adipisicing elit. Exercitationem voluptas perspiciatis est quis dolores!',
    image: IMAGE,
  },
  {
    title: 'Third Card with a long title that wraps',
    description: 'Lorem ipsum dolor sit amet consectetur adipisicing elit.',
    actions: [
      { request: {} as any, name: 'Fourth Button with a long label that wraps' },
      { request: {} as any, name: 'Fifth Button' },
    ],
  },
];

export const SingleCard: Story = {
  args: {
    cards: [FIRST_CARD],
  },
};

export const MultipleCards: Story = {
  args: {
    cards: MULTIPLE_CARDS,
  },
};

export const ControlsTemplate: Story = {
  args: {
    cards: MULTIPLE_CARDS,
  },

  render: (args) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const controlsRef = useRef<HTMLDivElement>(null);

    return (
      <ChatWidget.ChatContainer>
        <Chat.Dialog>
          <SystemResponse.Controls ref={controlsRef} />
          <SystemResponse.Container ref={containerRef} withImage scrollable>
            <Avatar avatar={VF_ICON} />
            <Carousel {...args} controlsRef={controlsRef} containerRef={containerRef} />
          </SystemResponse.Container>
        </Chat.Dialog>
      </ChatWidget.ChatContainer>
    );
  },
};

export const WithControls: Story = {
  args: {
    cards: MULTIPLE_CARDS,
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Carousel/CarouselButton.tsx

import type { MouseEventHandler } from 'react';
import { forwardRef } from 'react';

import Icon from '@/components/Icon';

import { ButtonContainer } from './styled';

export interface CarouselButtonProps {
  /**
   * The end of the container where the button will be rendered.
   */
  alignment: 'left' | 'right';

  /**
   * If true then the button will be visible, otherwise hidden.
   */
  visible: boolean;

  /**
   * The buttons will be centered vertically based on the height of this element.
   */
  containerEl: HTMLElement;

  /**
   * A click handler for the button.
   */
  onClick?: MouseEventHandler<HTMLButtonElement>;
}

/**
 * A button used to scroll to the previous or next Card in a Carousel.
 */
const CarouselButton = forwardRef<HTMLElement, CarouselButtonProps>(
  ({ onClick, alignment, visible, containerEl }, ref) => (
    <ButtonContainer
      ref={ref}
      alignment={alignment}
      visible={visible}
      css={{
        transform: `translateY(calc(${containerEl.clientHeight / 2}px - 50%))`,
      }}
      onClick={onClick}
    >
      <Icon svg="largeArrowLeft" />
    </ButtonContainer>
  )
);

export default CarouselButton;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Carousel/constants.ts

import { CARD_WIDTH } from '@/components/Card/styled';

import { CAROUSEL_GUTTER_WIDTH } from './styled';

export const CARD_WITH_BORDER_WIDTH = CARD_WIDTH + 2;
export const PREVIOUS_CONTROL_BOUNDARY = CARD_WITH_BORDER_WIDTH / 3;
export const NEXT_CONTROL_BOUNDARY = CARD_WITH_BORDER_WIDTH + CAROUSEL_GUTTER_WIDTH + PREVIOUS_CONTROL_BOUNDARY;
export const CARD_WITH_GUTTER_WIDTH = CARD_WITH_BORDER_WIDTH + CAROUSEL_GUTTER_WIDTH;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Carousel/hooks.ts

import type { RefObject } from 'react';
import { useEffect, useRef, useState } from 'react';

import type { CardProps } from '../Card';
import { CARD_WITH_GUTTER_WIDTH, NEXT_CONTROL_BOUNDARY, PREVIOUS_CONTROL_BOUNDARY } from './constants';
import { CAROUSEL_GUTTER_WIDTH } from './styled';

export const useScrollTo =
  <T extends HTMLElement>(ref: RefObject<T> | undefined, getNextIndex: (el: T) => number) =>
  () => {
    const el = ref?.current;
    if (!el) return;

    const index = getNextIndex(el);

    el.scrollTo({
      left: index && index * CARD_WITH_GUTTER_WIDTH,
      behavior: 'smooth',
    });
  };

export const useScrollObserver = (
  containerRef: RefObject<HTMLDivElement> | undefined,
  controlsRef: RefObject<HTMLSpanElement> | undefined,
  cards: CardProps[]
) => {
  const [showPreviousButton, setShowPreviousButton] = useState(false);
  const [showNextButton, setShowNextButton] = useState(false);
  const previousButtonRef = useRef<HTMLButtonElement>(null);
  const nextButtonRef = useRef<HTMLButtonElement>(null);
  const hasMultipleCards = cards.length > 1;

  useEffect(() => {
    if (!controlsRef?.current || !hasMultipleCards) return;

    setShowNextButton(true);
  }, []);

  useEffect(() => {
    const containerEl = containerRef?.current;
    if (!containerEl || !hasMultipleCards) return undefined;

    const trackWidth = CARD_WITH_GUTTER_WIDTH * cards.length - CAROUSEL_GUTTER_WIDTH;

    const handleScroll = (): void => {
      const { scrollLeft } = containerEl;

      setShowPreviousButton(scrollLeft >= PREVIOUS_CONTROL_BOUNDARY);
      setShowNextButton(scrollLeft <= trackWidth - NEXT_CONTROL_BOUNDARY);
    };

    containerEl.addEventListener('scroll', handleScroll);

    return () => {
      containerEl.removeEventListener('scroll', handleScroll);
    };
  }, []);

  return {
    previousButtonRef,
    nextButtonRef,
    showPreviousButton,
    showNextButton,
  };
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Carousel/index.tsx

import type { RefObject } from 'react';
import { createPortal } from 'react-dom';

import type { CardProps } from '@/components/Card';
import Card from '@/components/Card';

import CarouselButton from './CarouselButton';
import { CARD_WITH_GUTTER_WIDTH } from './constants';
import { useScrollObserver, useScrollTo } from './hooks';
import { Container } from './styled';

export interface CarouselProps {
  /**
   * A list of props objects which will be passed to {@link Card} components.
   */
  cards: CardProps[];

  /**
   * A reference to the HTML element of a parent horizontal scrolling container.
   */
  containerRef?: RefObject<HTMLDivElement>;

  /**
   * A reference to an HTML element to anchor the carousel controls.
   */
  controlsRef?: RefObject<HTMLSpanElement>;
}

const Carousel: React.FC<CarouselProps> = ({ cards, containerRef, controlsRef }) => {
  const { previousButtonRef, nextButtonRef, showPreviousButton, showNextButton } = useScrollObserver(
    containerRef,
    controlsRef,
    cards
  );
  const containerEl = containerRef?.current;
  const controlsEl = controlsRef?.current;
  const showControls = containerEl && controlsEl;

  const scrollToPrevious = useScrollTo(containerRef, (el) => Math.ceil(el.scrollLeft / CARD_WITH_GUTTER_WIDTH) - 1);
  const scrollToNext = useScrollTo(containerRef, (el) => Math.floor(el.scrollLeft / CARD_WITH_GUTTER_WIDTH) + 1);

  return (
    <>
      <Container>
        {cards.map((card, index) => (
          <Card {...card} key={index} />
        ))}
      </Container>
      {showControls &&
        createPortal(
          <>
            <CarouselButton
              ref={previousButtonRef}
              alignment="left"
              visible={showPreviousButton}
              containerEl={containerEl}
              onClick={scrollToPrevious}
            />
            <CarouselButton
              ref={nextButtonRef}
              alignment="right"
              visible={showNextButton}
              containerEl={containerEl}
              onClick={scrollToNext}
            />
          </>,
          controlsEl
        )}
    </>
  );
};

/**
 * A carousel of {@link Card} components that can be scrolled natively or with buttons.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-carousel--single-card}
 */
export default Object.assign(Carousel, {
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Carousel/styled.ts

import Card from '@/components/Card';
import Icon from '@/components/Icon';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const BUTTON_SIZE = 42;
export const CAROUSEL_GUTTER_WIDTH = 12;

const tag = tagFactory(ClassName.CAROUSEL);

export const ButtonContainer = styled(tag('span', 'button'), {
  position: 'absolute',
  zIndex: 1,

  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  borderRadius: '$round',
  trans: ['background-color', 'box-shadow', 'opacity'],

  height: BUTTON_SIZE,
  width: BUTTON_SIZE,
  cursor: 'pointer',
  backgroundColor: '$white',
  color: '$black',
  boxShadow: '0 1px 3px 1px $shadow1, 0 0 0 1px $shadow3, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12',
  border: 'none',

  [`& ${Icon.Frame}`]: {
    height: '$xxs',
    width: '$xxs',
    color: 'rgba(0,0,0,0.6)',
    trans: ['color'],
  },

  '&:hover': {
    boxShadow: '0 1px 4px 1px $shadow4, 0 0 0 1px $shadow4, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12',
  },

  '&:active': {
    boxShadow: '0 1px 4px 1px $shadow8, 0 0 0 1px $shadow4, 0 2px 4px -3px $shadow12, 0 5px 8px -8px $shadow12',
  },

  [`
      &:hover ${Icon.Frame},
      &:active ${Icon.Frame}
    `]: {
    color: 'rgba(0,0,0,0.8)',
  },

  variants: {
    visible: {
      true: {
        opacity: 1,
        pointerEvents: 'auto',
      },
      false: {
        opacity: 0,
        pointerEvents: 'none',
      },
    },
    alignment: {
      left: {
        left: 48 - BUTTON_SIZE / 2,
      },
      right: {
        right: 70 - BUTTON_SIZE / 2,

        [`& ${Icon.Frame}`]: {
          transform: 'scaleX(-1)',
        },
      },
    },
  },
});

export const Container = styled(tag('div'), {
  display: 'flex',
  whiteSpace: 'nowrap',

  [`& ${Card.Container}`]: {
    height: 'fit-content',
    flexShrink: 0,
    marginLeft: CAROUSEL_GUTTER_WIDTH,

    '&:first-of-type': {
      marginLeft: 0,
    },
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Chat/Chat.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import type { SystemResponseProps } from '@/components/SystemResponse';
import SystemResponse from '@/components/SystemResponse';
import type { UserResponseProps } from '@/components/UserResponse';
import UserResponse from '@/components/UserResponse';
import { MOCK_IMAGE, VF_ICON } from '@/fixtures';

import Chat from '.';

const meta: Meta<typeof Chat> = {
  title: 'Templates/Chat',
  component: Chat,
  args: {
    isLoading: false,
    actions: [],
    title: 'Assistant Name',
    withWatermark: true,
    image: VF_ICON,
    description: "Voiceflow's virtual assistant is here to help.",
    startTime: Date.now(),
    hasEnded: false,
  },
};

export default meta;

type Story = StoryObj<typeof Chat>;

const SystemResponseTemplate = ({ messages, ...args }: Partial<SystemResponseProps>) => {
  return <SystemResponse {...args} messages={messages as any} avatar={VF_ICON} timestamp={Date.now()} />;
};

const UserResponseTemplate = ({ message, ...args }: Partial<UserResponseProps>) => (
  <UserResponse timestamp={Date.now()} message={message || 'Lorem ipsum dolor'} {...args} />
);

export const Empty: Story = {};

export const Exhaustive: Story = {
  render: (args) => {
    return (
      <Chat {...args}>
        <SystemResponseTemplate messages={[{ type: 'text', text: 'Lorem ipsum dolor' }]} />
        <SystemResponseTemplate messages={[{ type: 'image', url: MOCK_IMAGE }]} />
        <UserResponseTemplate />
        <SystemResponseTemplate
          messages={[
            {
              type: 'text',
              text: 'Lorem ipsum dolor lorem ipsum dolor lorem ipsum dolor consecteturaconsect turaconse lorem teturaconsecteturaconsecteturaconsectetura consectetura',
            },
          ]}
        />
        <UserResponseTemplate message="Lorem ipsum dolor lorem ipsum dolor lorem ipsum dolor consecteturaconsect turaconse lorem teturaconsecteturaconsecteturaconsectetura consecteturac onsecteturaconsecteturaconsecteturaco nsecteturaconsectetura" />
        <SystemResponseTemplate
          messages={[
            {
              type: 'card',
              title: 'Card Message',
              description:
                'Lorem ipsum dolor sit amet consectetur adipisicing elit. Exercitationem voluptas perspiciatis est quis dolores!',
              image: MOCK_IMAGE,
            },
          ]}
        />
      </Chat>
    );
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Chat/hooks.ts

import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import { useMemo } from 'react';

import type { Nullish } from '@/types';

dayjs.extend(relativeTime);

export const useTimestamp = (startTime?: Nullish<number>) => {
  return useMemo(() => {
    if (!startTime) return null;

    const start = dayjs(startTime);
    const now = dayjs();

    switch (true) {
      case now.isSame(start, 'day'):
        return 'Today';
      case now.subtract(1, 'day').isSame(start, 'day'):
        return 'Yesterday';
      default:
        return start.fromNow();
    }
  }, [startTime]);
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Chat/index.tsx

import React, { memo, useContext, useMemo, useRef, useState } from 'react';

import type { AssistantInfoProps } from '@/components/AssistantInfo';
import AssistantInfo from '@/components/AssistantInfo';
import type { FooterProps } from '@/components/Footer';
import Footer from '@/components/Footer';
import type { HeaderActionProps, HeaderProps } from '@/components/Header';
import Header from '@/components/Header';
import Loader from '@/components/Loader';
import Prompt from '@/components/Prompt';
import { AutoScrollProvider, RuntimeStateAPIContext, RuntimeStateContext } from '@/contexts';
import { RenderMode } from '@/dtos/RenderOptions.dto';
import type { Nullish } from '@/types';
import { chain } from '@/utils/functional';

import { useTimestamp } from './hooks';
import { Container, Dialog, Overlay, SessionTime, Spacer, Status } from './styled';

export interface ChatProps extends HeaderProps, AssistantInfoProps, FooterProps, React.PropsWithChildren<unknown> {
  /**
   * A short description of the assistant to help frame the conversation.
   */
  description: string;

  /**
   * If true, shows a loading indicator.
   */
  isLoading: boolean;

  /**
   * If true, shows audio interface controls.
   */
  audioInterface?: boolean;

  /**
   * A unix timestamp indicating the start of the conversation.
   */
  startTime?: Nullish<number>;

  /**
   * If true, a Voiceflow watermark is added to the footer.
   */
  withWatermark: boolean;

  /**
   * A callback that is executed when the chat widget is minimized.
   */
  onMinimize?: React.MouseEventHandler<HTMLButtonElement>;

  /**
   * A callback that is executed when the conversation ends.
   */
  onEnd?: React.MouseEventHandler<HTMLButtonElement>;
}

const Chat: React.FC<ChatProps> = ({
  hasEnded = false,
  title,
  image,
  avatar,
  description,
  startTime,
  isLoading,
  withWatermark,
  onMinimize,
  onEnd,
  onStart,
  onSend,
  children,
  audioInterface,
}) => {
  const timestamp = useTimestamp(startTime);
  const dialogRef = useRef<HTMLElement>(null);
  const [hasAlert, setAlert] = useState(false);

  const { config, toggleAudioOutput } = useContext(RuntimeStateAPIContext);
  const state = useContext(RuntimeStateContext);

  const handleClose = (event: React.MouseEvent<HTMLButtonElement>): void => {
    if (hasEnded) {
      onEnd?.(event);
    } else {
      setAlert(true);
    }
  };

  const handleResume = (): void => setAlert(false);

  const actions = useMemo<HeaderActionProps[]>(() => {
    const items: HeaderActionProps[] = [{ svg: 'close', onClick: handleClose }];

    if (config.render?.mode === RenderMode.OVERLAY) {
      items.unshift({ svg: 'minus', onClick: onMinimize });
    }

    if (audioInterface) {
      items.unshift({
        svg: state.audioOutput ? 'sound' : 'soundOff',
        onClick: toggleAudioOutput,
      });
    }

    return items;
  }, [config.render, handleClose, onMinimize, state.audioOutput, audioInterface]);

  if (isLoading) {
    return (
      <Container>
        <Loader />
      </Container>
    );
  }

  return (
    <Container withPrompt={hasAlert}>
      <Header title={title} image={image} actions={actions} />
      <Dialog ref={dialogRef}>
        <AutoScrollProvider target={dialogRef}>
          <AssistantInfo title={title} avatar={avatar} description={description} />
          <Spacer />
          {!!timestamp && !!state.session.turns.length && <SessionTime>{timestamp}</SessionTime>}
          {children}
          {hasEnded && !!state.session.turns.length && <Status>The chat has ended</Status>}
        </AutoScrollProvider>
      </Dialog>
      <Footer
        withWatermark={withWatermark}
        hasEnded={hasEnded}
        onStart={onStart}
        onSend={onSend}
        disableSend={state.indicator}
        audioInterface={audioInterface}
        speechRecognition={config.speechRecognition}
      />
      <Overlay />
      <Prompt
        accept={{ label: 'End Chat', type: 'warn', onClick: chain(onEnd, handleResume) }}
        cancel={{ label: 'Cancel', onClick: handleResume }}
      />
    </Container>
  );
};

/**
 * A full chat dialog with header, footer, overlay and auto-scrolling content.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/templates-chat--empty}
 */
export default Object.assign(memo(Chat), {
  Container,
  Dialog,
  Overlay,
  Spacer,
  Status,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Chat/styled.ts

import AssistantInfo from '@/components/AssistantInfo';
import { Container as FooterContainer } from '@/components/Footer/styled';
import Header from '@/components/Header';
import Loader from '@/components/Loader';
import Prompt from '@/components/Prompt';
import SystemResponse from '@/components/SystemResponse';
import Timestamp from '@/components/Timestamp';
import UserResponse from '@/components/UserResponse';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import type { CSS } from '@/styles';
import { animationStyles, createTransition, fadeIn, styled } from '@/styles';

const PROMPT_OVERFLOW = 10;

const tag = tagFactory(ClassName.CHAT);

export const Overlay = styled(tag('div', 'overlay'), {
  position: 'absolute',
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  backgroundColor: '$shadow12',
});

export const Container = styled(tag('article'), {
  position: 'relative',
  display: 'flex',
  overflow: 'hidden',
  flexDirection: 'column',
  backgroundColor: '$white',

  [`& > ${Loader}`]: {
    margin: 'auto',
  },

  [`& ${Header.Container}`]: {
    animation: `${fadeIn} 150ms ease forwards`,
  },

  [`& ${FooterContainer}`]: { // Update here
    ...animationStyles({ duration: 300, delay: 300 }),
  },

  [`& ${Overlay}`]: {
    opacity: 0,
    pointerEvents: 'none',
    trans: ['opacity'],
  },

  [`& ${Prompt.Container}`]: {
    position: 'absolute',
    bottom: 0,
    width: '100%',
    boxSizing: 'border-box',
    paddingBottom: `calc($3 + ${PROMPT_OVERFLOW}px)`,
    transition: `transform 320ms cubic-bezier(0.45, 1.29, 0.64, 1), ${createTransition(['box-shadow'], 300)}`,
    transform: `translateY(calc(100% + ${PROMPT_OVERFLOW}px))`,
  },

  variants: {
    withPrompt: {
      true: {
        [`& ${Overlay}`]: {
          opacity: 1,
          zIndex: 2,
          pointerEvents: 'auto',
        },

        [`& ${Prompt.Container}`]: {
          zIndex: 3,
          transform: `translateY(${PROMPT_OVERFLOW}px)`,
        },
      },
      false: {
        [`& ${Prompt.Container}`]: {
          boxShadow: 'none',
        },
      },
    },
  },
});

const statusStyles: CSS = {
  display: 'flex',
  justifyContent: 'center',
  typo: { size: 12 },
  color: '$darkGrey',
};

export const Status = styled(tag('div', 'status'), {
  ...statusStyles,
});

export const SessionTime = styled(tag('span', 'session-time'), {
  ...statusStyles,
  paddingBottom: '$3',
});

export const Dialog = styled(tag('main', 'dialog'), {
  display: 'flex',
  flexDirection: 'column',
  height: '100%',
  overflowY: 'scroll',
  overflowX: 'hidden',
  paddingBottom: '$3',

  [`
    & ${UserResponse.Container},
    & ${SystemResponse.List},
    & ${SystemResponse.Actions},
    & ${AssistantInfo.Container}
  `]: {
    ...animationStyles({ duration: 150, delay: 0 }),
  },

  [`
    & > ${UserResponse.Container},
    & > ${SystemResponse.Container}
  `]: {
    padding: '0 $5',
  },

  [`& > ${SystemResponse.Actions}`]: {
    padding: '0 $5 0 54px',
  },

  [`& ${SystemResponse.Container}`]: {
    marginBottom: '$1',

    '&:last-of-type': {
      marginBottom: 0,
    },
  },

  [`& ${UserResponse.Container} + ${UserResponse.Container}`]: {
    marginTop: '$1',
  },

  [`
    & ${SystemResponse.Container} + ${UserResponse.Container},
    & ${SystemResponse.Actions} + ${UserResponse.Container},
    & ${UserResponse.Container} + ${SystemResponse.Controls} + ${SystemResponse.Container}
  `]: {
    marginTop: '$5',
  },

  [`& ${Timestamp.Container}`]: { width: 50 },

  [`& ${Status}`]: {
    marginTop: '$3',
    marginBottom: 8,
  },
});

export const Spacer = styled(tag('div', 'spacer'), {
  flexGrow: 1,
});

// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/ChatInput/AudioInputButton.tsx

import Icon from '../Icon';
import { AutoInputButtonContainer } from './styled';

interface AudioInputButtonProps {
  onStop: () => void;
  onStart: () => void;
  listening: boolean;
  processing: boolean;
  initializing: boolean;
}

export const AudioInputButton: React.FC<AudioInputButtonProps> = ({
  onStop,
  onStart,
  listening,
  processing,
  initializing,
}) => {
  return (
    <AutoInputButtonContainer
      onClick={listening ? onStop : onStart}
      disabled={processing || initializing}
      listening={listening}
    >
      <Icon svg={listening ? 'stop' : 'microphone'} />
    </AutoInputButtonContainer>
  );
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/ChatInput/ChatInput.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import ChatInput from '.';

type Story = StoryObj<typeof ChatInput>;

const meta: Meta<typeof ChatInput> = {
  title: 'Components/Chat/ChatInput',
  component: ChatInput,
  args: {
    value: '',
    placeholder: '',
  },
  parameters: {
    controls: { include: ['value', 'placeholder', 'onValueChange'] },
  },
  render: (args) => <ChatInput.Controlled {...args} />,
};

export default meta;

export const Default: Story = {};

export const Placeholder: Story = {
  args: {
    placeholder: 'Messageâ€¦',
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/ChatInput/hooks.ts

import { useEffect, useLayoutEffect, useRef, useState } from 'react';
import ReactSpeechRecognition, { useSpeechRecognition as useReactSpeechRecognition } from 'react-speech-recognition';

import { isChrome } from '@/device';
import type { ChatSpeechRecognitionConfig, ChatSpeechRecognitionState } from '@/dtos/ChatConfig.dto';

export const useSpeechRecognition = ({
  onSend,
  onValueChange,
  customSpeechRecognition,
}: {
  onSend?: () => void;
  onValueChange: (value: string) => void;
  customSpeechRecognition?: ChatSpeechRecognitionConfig;
}) => {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const reactSpeechRecognition = useReactSpeechRecognition({ clearTranscriptOnListen: true });

  const browserSupportsSpeechRecognition = reactSpeechRecognition.browserSupportsSpeechRecognition && isChrome();
  const customSpeechRecognitionEnabled =
    !!customSpeechRecognition && (customSpeechRecognition.overrideNative || !browserSupportsSpeechRecognition);

  const prevListening = useRef(
    customSpeechRecognitionEnabled ? customSpeechRecognition.initialState.listening : reactSpeechRecognition.listening
  );
  const prevProcessing = useRef(
    customSpeechRecognitionEnabled ? customSpeechRecognition.initialState.processing : false
  );
  const onSendPersisted = useRef(onSend);
  onSendPersisted.current = onSend;

  const [customSpeechRecognitionState, setCustomSpeechRecognitionState] = useState<ChatSpeechRecognitionState>(
    customSpeechRecognitionEnabled
      ? customSpeechRecognition.initialState
      : {
          listening: reactSpeechRecognition.listening,
          transcript: reactSpeechRecognition.transcript,
          processing: false,
          initializing: false,
          microphoneAvailable: reactSpeechRecognition.isMicrophoneAvailable,
        }
  );

  const onStartListening = (): void => {
    if (customSpeechRecognitionEnabled) {
      customSpeechRecognition.resetTranscript();
      customSpeechRecognition.startListening();
    } else {
      reactSpeechRecognition.resetTranscript();
      ReactSpeechRecognition.startListening({ continuous: true });
    }
  };

  const onStopListening = (): void => {
    if (customSpeechRecognitionEnabled) {
      customSpeechRecognition.stopListening();
    } else {
      ReactSpeechRecognition.stopListening();
    }
  };

  useLayoutEffect(() => {
    if (customSpeechRecognitionEnabled || !reactSpeechRecognition.listening) return;

    onValueChange(reactSpeechRecognition.transcript);
  }, [customSpeechRecognitionEnabled, reactSpeechRecognition.transcript]);

  useEffect(() => {
    if (customSpeechRecognitionEnabled) {
      if (prevProcessing.current && !customSpeechRecognitionState.processing) {
        onSendPersisted.current?.();
        customSpeechRecognition.resetTranscript();
        textareaRef.current?.focus();
      }

      prevProcessing.current = customSpeechRecognitionState.processing;
    } else {
      if (prevListening.current && !reactSpeechRecognition.listening) {
        onSendPersisted.current?.();
        reactSpeechRecognition.resetTranscript();
        textareaRef.current?.focus();
      }

      prevListening.current = reactSpeechRecognition.listening;
    }
  }, [customSpeechRecognitionEnabled, reactSpeechRecognition.listening, customSpeechRecognitionState.processing]);

  useEffect(() => {
    if (!customSpeechRecognitionEnabled) return undefined;

    return customSpeechRecognition.onStateChange((nextState) => {
      onValueChange(nextState.transcript);
      setCustomSpeechRecognitionState(nextState);
    });
  }, [customSpeechRecognitionEnabled]);

  return {
    available: customSpeechRecognitionEnabled || browserSupportsSpeechRecognition,
    listening: customSpeechRecognitionEnabled
      ? customSpeechRecognitionState.listening
      : reactSpeechRecognition.listening,
    processing: customSpeechRecognitionEnabled ? customSpeechRecognitionState.processing : false,
    textareaRef,
    initializing: customSpeechRecognitionEnabled ? customSpeechRecognitionState.initializing : false,
    stopListening: onStopListening,
    startListening: onStartListening,
    microphoneAvailable: customSpeechRecognitionEnabled
      ? customSpeechRecognitionState.microphoneAvailable
      : reactSpeechRecognition.isMicrophoneAvailable,
  };
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/ChatInput/index.tsx

import cuid from 'cuid';
import { useMemo } from 'react';

import Bubble from '@/components/Bubble';
import type { TextareaProps } from '@/components/Textarea';
import Textarea from '@/components/Textarea';
import type { ChatSpeechRecognitionConfig } from '@/dtos/ChatConfig.dto';
import { createControlled } from '@/utils/controls';

import { AudioInputButton } from './AudioInputButton';
import { useSpeechRecognition } from './hooks';
import { ButtonContainer, Container } from './styled';

export interface ChatInputProps extends TextareaProps {
  /**
   * If true, does not allow the user to submit a response.
   */
  disableSend?: boolean | undefined;

  /**
   * if true, shows audio interface controls.
   */
  audioInterface?: boolean | undefined;

  /**
   * A callback to submit the user response.
   */
  onSend?: VoidFunction;

  /**
   * Custom speech recognition implementation.
   */
  speechRecognition?: ChatSpeechRecognitionConfig;
}

const ChatInput: React.FC<ChatInputProps> = ({
  id,
  onSend,
  placeholder,
  disableSend,
  onValueChange,
  audioInterface,
  speechRecognition: customSpeechRecognition,
  ...props
}) => {
  const internalID = useMemo(() => `vf-chat-input--${cuid()}`, []) ?? id;
  const speechRecognition = useSpeechRecognition({ onSend, onValueChange, customSpeechRecognition });

  const handleKeyPress = (event: React.KeyboardEvent<HTMLTextAreaElement>): void => {
    event.stopPropagation();

    const { shiftKey } = event;

    if (event.key !== 'Enter') return;
    if (event.key === 'Enter' && !shiftKey) {
      event.preventDefault();
      onSend?.();
    }
  };

  const withSendButton = !!props.value && !disableSend && !speechRecognition.listening;
  const withAudioInput =
    speechRecognition.available && speechRecognition.microphoneAvailable && audioInterface && !withSendButton;

  const getPlaceholder = () => {
    if (speechRecognition.initializing) {
      return 'Initializing...';
    }

    if (speechRecognition.listening) {
      return 'Listening...';
    }

    if (speechRecognition.processing) {
      return 'Processing...';
    }

    return placeholder;
  };

  return (
    <Container>
      <Textarea
        id={internalID}
        ref={speechRecognition.textareaRef}
        readOnly={speechRecognition.initializing || speechRecognition.processing || speechRecognition.listening}
        onKeyDown={handleKeyPress}
        placeholder={getPlaceholder()}
        onValueChange={onValueChange}
        {...props}
      />

      <ButtonContainer htmlFor={internalID} ready={withSendButton}>
        <Bubble size="small" svg="smallArrowUp" onClick={onSend} />
      </ButtonContainer>

      {withAudioInput && (
        <AudioInputButton
          onStop={speechRecognition.stopListening}
          onStart={speechRecognition.startListening}
          listening={speechRecognition.listening}
          processing={speechRecognition.processing}
          initializing={speechRecognition.initializing}
        />
      )}
    </Container>
  );
};

/**
 * An input control with a built-in submit button.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-chat-chatinput--default}
 */
export default Object.assign(ChatInput, {
  Controlled: createControlled(ChatInput, {
    defaultValue: '',
    enrichProps: (props, [, setValue]) => ({
      ...props,
      onSend: (): void => {
        setValue('');
        props.onSend?.();
      },
    }),
  }),
  Container,
  ButtonContainer,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/ChatInput/styled.ts

import Bubble from '@/components/Bubble';
import Icon from '@/components/Icon';
import { textareaFocusStyles, textareaStyles } from '@/components/Textarea/styled';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

import Textarea from '../Textarea';

const tag = tagFactory(ClassName.CHAT_INPUT);

export const ButtonContainer = styled(tag('label', 'button'), {
  ...textareaStyles,
  display: 'inline-flex',
  justifyContent: 'center',
  alignItems: 'center',
  paddingBottom: '8px',
  width: '$md',
  borderRadius: '$1',
  boxSizing: 'border-box',
  cursor: 'text',
  pointerEvents: 'none',

  [`& ${Bubble.Container}`]: {
    transform: 'scale(0)',
    marginTop: 'auto',
    trans: ['background-color', 'transform'],
  },

  variants: {
    ready: {
      true: {
        [`& ${Bubble.Container}`]: {
          transform: 'scale(1)',
          cursor: 'pointer',
          pointerEvents: 'all',
        },
      },
    },
  },
});

export const Container = styled(tag('div'), {
  display: 'flex',
  boxShadow: '0 1px 12px $shadow2',
  trans: ['border-color', 'box-shadow'],
  position: 'relative',

  [`& ${Textarea.Container}`]: {
    ...textareaStyles,
    minHeight: '$md',
    margin: 0,
    borderRightWidth: 0,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0,
    paddingRight: 7,
    boxShadow: 'none',
  },

  [`& ${ButtonContainer}`]: {
    height: 'inherit',
    borderLeftWidth: 0,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0,
  },

  [`& ${Icon.Frame}`]: {
    color: '$white',
  },

  [`& ${Textarea.Container}:focus`]: {
    ...textareaFocusStyles,
    borderRightWidth: 0,
  },

  [`& ${Textarea.Container}:focus + ${ButtonContainer}`]: {
    ...textareaFocusStyles,
    borderLeftWidth: 0,
  },
});

export const AutoInputButtonContainer = styled(tag('button'), {
  width: '$md',
  position: 'absolute',
  right: 0,
  top: 0,
  bottom: 0,
  border: 'none',
  background: 'transparent',
  cursor: 'pointer',
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  borderRadius: 0,

  [`&& ${Icon.Frame}`]: {
    color: '$darkGrey',
    opacity: 0.8,
    trans: ['opacity', 'color'],
  },

  '&:hover': {
    [`&& ${Icon.Frame}`]: {
      opacity: 1,
    },
  },

  '&:active': {
    [`&& ${Icon.Frame}`]: {
      color: '$black',
      opacity: 1,
    },
  },

  variants: {
    listening: {
      true: {
        [`&& ${Icon.Frame}`]: {
          color: '$warn',
        },

        '&:active': {
          [`&& ${Icon.Frame}`]: {
            color: '$warn',
          },
        },
      },
    },

    disabled: {
      true: {
        cursor: 'not-allowed',

        [`&& ${Icon.Frame}`]: {
          opacity: 0.5,
        },
      },
    },
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Feedback/index.tsx

import React from 'react';

import { thumbsUp as ThumbsUp } from '@/assets/svg';
import { FeedbackName } from '@/contexts/RuntimeContext/useRuntimeAPI';

import { Button, ButtonsContainer, Container, Description } from './styled';

export interface FeedbackProps extends React.PropsWithChildren {
  /**
   * Alternative question to ask the user
   *
   * @default 'Was this helpful?'
   */
  question?: string;

  onClick: (feedback: FeedbackName) => void;
}

const Feedback: React.FC<FeedbackProps> = ({ question = 'Was this helpful?', onClick, ...props }) => {
  const [active, setActive] = React.useState<FeedbackName | null>(null);

  const handleClick = (feedback: FeedbackName) => {
    if (feedback === active) return;
    onClick(feedback);
    setActive(feedback);
  };

  return (
    <Container {...props}>
      <Description>{question}</Description>
      <ButtonsContainer>
        <Button
          orientation="positive"
          active={active === FeedbackName.POSITIVE}
          onClick={() => handleClick(FeedbackName.POSITIVE)}
        >
          <ThumbsUp width="24px" height="24px" />
        </Button>
        <Button
          orientation="negative"
          active={active === FeedbackName.NEGATIVE}
          onClick={() => handleClick(FeedbackName.NEGATIVE)}
        >
          <ThumbsUp width="24px" height="24px" />
        </Button>
      </ButtonsContainer>
    </Container>
  );
};

export default Feedback;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Feedback/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.FEEDBACK);

export const Container = styled(tag('div'), {
  display: 'inline-flex',
  alignItems: 'center',
  boxSizing: 'border-box',
  marginTop: '8.5px',
});

export const Description = styled(tag('div', 'description'), {
  color: '$darkGrey',
  marginRight: 4,
  lineHeight: 17,
  typo: {
    size: 12,
  },
});

export const ButtonsContainer = styled(tag('div', 'buttons'), {
  display: 'flex',
  gap: 4,
});

export const Button = styled(tag('button', 'button'), {
  display: 'inline-flex',
  backgroundColor: 'transparent',
  border: 0,
  borderRadius: '$round',

  width: 24,
  height: 24,
  padding: 0,
  margin: 0,
  cursor: 'pointer',

  variants: {
    active: {
      false: {
        color: 'rgb(115 115 118 / 85%)',
        '&:hover': {
          color: 'rgb(115 115 118 / 100%)',
        },
      },

      true: {
        color: '$white',
        backgroundColor: '$primary',
      },
    },
    orientation: {
      positive: {
        transform: 'none',
      },
      negative: {
        transform: 'rotate(180deg)',
      },
    },
  },

  defaultVariants: {
    active: false,
    orientation: 'positive',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Footer/Footer.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Chat from '@/components/Chat';

import Footer from '.';

type Story = StoryObj<typeof Footer>;

const meta: Meta<typeof Footer> = {
  title: 'Components/Chat/Footer',
  component: Footer,
  argTypes: {
    onStart: { action: 'onStart' },
    onSend: { action: 'send' },
  },
  args: {
    hasEnded: false,
    withWatermark: false,
  },
  render: (args) => (
    <Chat.Container>
      <Footer {...args} />
    </Chat.Container>
  ),
};

export default meta;

export const Running: Story = {};

export const Ended: Story = {
  args: {
    hasEnded: true,
  },
};

export const WithWatermark: Story = {
  args: {
    withWatermark: true,
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Footer/index.tsx

import { useState } from 'react';
import Button from '@/components/Button';
import ChatInput from '@/components/ChatInput';
import MainMenuButton from '@/components/MainMenuButton';
import { Container, Watermark, InteractionWrapper, InputWrapper, StartNewChatWrapper, FullWidthButtonWrapper } from './styled';

export interface FooterProps {
  withWatermark: boolean;
  hasEnded?: boolean;
  disableSend?: boolean;
  audioInterface?: boolean;
  onStart?: (() => Promise<void>) | undefined;
  onSend?: ((message: string) => Promise<void>) | undefined;
  speechRecognition?: any;
}

const Footer: React.FC<FooterProps> = ({
  withWatermark,
  hasEnded,
  disableSend,
  onStart,
  onSend,
  audioInterface,
  speechRecognition,
}) => {
  const [message, setMessage] = useState('');

  const handleSend = async (): Promise<void> => {
    if (!message || disableSend) return;

    setMessage('');
    await onSend?.(message);
  };

  const handleMenuActionSelect = (action: string) => {
    switch (action) {
      case 'exploreTours':
        onSend?.('Explore Tours');
        break;
      case 'viewBookings':
        onSend?.('View Bookings');
        break;
      case 'contactSupport':
        onSend?.('Contact Support');
        break;
      default:
        break;
    }
  };

  return (
    <Container>
      {hasEnded ? (
        <StartNewChatWrapper>
          <FullWidthButtonWrapper>
            <Button onClick={onStart}>Start New Chat</Button>
          </FullWidthButtonWrapper>
          {withWatermark && (
            <Watermark>
              Assistant âš¡ï¸ by
              <a target="_blank" href="https://www.romaix.ai/" rel="noreferrer">
                RomAIx
              </a>
            </Watermark>
          )}
        </StartNewChatWrapper>
      ) : (
        <>
          <InteractionWrapper>
            <MainMenuButton onActionSelect={handleMenuActionSelect} />
            <InputWrapper>
              <ChatInput
                value={message}
                placeholder="Messageâ€¦"
                autoFocus
                onValueChange={setMessage}
                onSend={handleSend}
                disableSend={disableSend}
                audioInterface={audioInterface}
                speechRecognition={speechRecognition}
              />
            </InputWrapper>
          </InteractionWrapper>
          {withWatermark && (
            <Watermark>
              Assistant âš¡ï¸ by
              <a target="_blank" href="https://www.romaix.ai/" rel="noreferrer">
                RomAIx
              </a>
            </Watermark>
          )}
        </>
      )}
    </Container>
  );
};

export default Footer;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Footer/styled.ts

import { styled } from '@/styles';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import Button from '@/components/Button';
import Input from '@/components/Input';

// Define the tag for styling
const tag = tagFactory(ClassName.FOOTER);

// Styled Container for Footer
export const Container = styled(tag('footer'), {
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  padding: '$3 $4',
  borderRadius: '$1',

  variants: {
    withShadow: {
      true: {
        boxShadow: '0 12px 48px $shadow16',
      },
    },
  },
});

export const InteractionWrapper = styled('div', {
  display: 'flex',
  alignItems: 'center',
  width: '100%',
  marginBottom: '$2',
});

export const InputWrapper = styled('div', {
  flex: 1,
  display: 'flex',
  flexDirection: 'column',

  [`& ${Input.Container}`]: {
    width: '100%',
  },
});

export const StartNewChatWrapper = styled('div', {
  width: '100%',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',

  [`& ${Button}`]: {
    width: '100%',
    padding: '10px 0',
  },
});

export const FullWidthButtonWrapper = styled('div', {
  width: '100%',
  display: 'flex',
  justifyContent: 'center',

  '& button': {
    width: '100%', // Ensure the button takes the full width of its wrapper
    padding: '10px 0', // Adjust padding as needed
  },
});

export const Watermark = styled(tag('aside', 'watermark'), {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  padding: '4px 0',
  typo: { size: 12, height: '17px' },
  color: '$darkGrey',

  '& a': {
    marginLeft: '0.5ch',
    textDecoration: 'none',
    color: '$blue',

    '&:focus': {
      outline: 0,
    },
  },
});

// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Header/Header.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Chat from '@/components/Chat';
import { VF_ICON } from '@/fixtures';

import Header from '.';

const meta: Meta<typeof Header> = {
  title: 'Components/Chat/Header',
  component: Header,
  args: {
    title: 'Assistant Name',
    image: VF_ICON,
    actions: [],
  },
  render: (args) => (
    <Chat.Container>
      <Header {...args} />
    </Chat.Container>
  ),
};

export default meta;

type Story = StoryObj<typeof Header>;

export const Base: Story = {};

export const Actionable: Story = {
  args: {
    actions: [{ svg: 'minus' }, { svg: 'close' }],
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Header/index.tsx

import Avatar from '@/components/Avatar';
import type { IconProps } from '@/components/Icon';
import Icon from '@/components/Icon';

import { Button, Container, Title } from './styled';

export interface HeaderActionProps {
  /**
   * The name of the SVG icon that will be used for the button or a React component.
   *
   * @see {@link https://github.com/voiceflow/react-chat/tree/master/packages/react-chat/src/assets/svg the available icons}
   */
  svg: IconProps['svg'];

  /**
   * A callback that is executed when the button is clicked.
   */
  onClick?: React.MouseEventHandler<HTMLButtonElement> | undefined;
}

export interface HeaderProps {
  /**
   * The name of your assistant or title of the conversation.
   */
  title: string;

  /**
   * An image URL that will be rendered as a small {@link Avatar}.
   */
  image: string;

  /**
   * A list of actions that will appear as icon buttons.
   */
  actions?: HeaderActionProps[];
}

const Header: React.FC<HeaderProps> = ({ title, image, actions = [] }) => (
  <Container>
    <Avatar avatar={image} />
    <Title>{title}</Title>
    {actions.map(({ svg, onClick }, index) => (
      <Button onClick={onClick} key={index}>
        <Icon svg={svg} />
      </Button>
    ))}
  </Container>
);

/**
 * Header for the chat widget with image, title and controls.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/docs/components-chat-header--simple}
 */
export default Object.assign(Header, {
  Container,
  Title,
  Button,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Header/styled.ts

import Avatar from '@/components/Avatar';
import BaseButton from '@/components/Button';
import Icon from '@/components/Icon';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';
import { textOverflowStyles } from '@/styles/fragments';

const tag = tagFactory(ClassName.HEADER);

export const Title = styled(tag('h1', 'title'), {
  ...textOverflowStyles,
  typo: { size: 17, weight: '$2', height: '$2' },
  color: 'rgba(255,255,255,0.95)',
});

export const Button = styled(tag(BaseButton.Reset, 'button'), {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  height: 32,
  width: 32,
  marginLeft: 8,
  borderRadius: 6,
  background: 'none',
  trans: ['background-color'],

  '&:hover': {
    backgroundColor: 'rgba(255,255,255,0.16)',

    [`& ${Icon.Frame}`]: {
      color: '$white',
    },
  },

  [`& ${Icon.Frame}`]: {
    height: '$xxs',
    width: '$xxs',
    color: 'rgba(255,255,255,0.8)',
    trans: ['color'],
  },
});

export const Container = styled(tag('header'), {
  display: 'flex',
  flexShrink: 0,
  alignItems: 'center',
  height: '$lg',
  padding: '0 $4 0 $5',
  backgroundColor: '$primary',
  boxShadow: '0 1px 2px $shadow16',

  [`& ${Avatar.Container}`]: {
    height: 32,
    width: 32,
  },

  [`& ${Title}`]: {
    flex: 1,
    margin: '0 0 0 14px',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Icon/Icon.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import * as SVGs from '@/assets/svg';

import Icon from '.';

type Story = StoryObj<typeof Icon>;

const meta: Meta<typeof Icon> = {
  title: 'Core/Icon',
  component: Icon,
  argTypes: {
    svg: {
      options: Object.keys(SVGs).filter((svg) => svg !== 'topCaret'),
      control: { type: 'radio' },
    },
  },
  parameters: {
    controls: { include: ['svg'] },
  },
};

export default meta;
export const Default: Story = {
  args: {
    svg: 'close',
    css: {
      height: 50,
      width: 50,
    },
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Icon/index.tsx

import * as SVGs from '@/assets/svg';

import { Frame } from './styled';

export type SVG = keyof typeof SVGs;

export interface IconProps extends React.ComponentProps<typeof Frame> {
  /**
   * The name of the SVG icon to be rendered or a React component.
   *
   * @see {@link https://github.com/voiceflow/react-chat/tree/master/packages/react-chat/src/assets/svg the available icons}
   */
  svg: SVG | React.ComponentType;
}

const Icon: React.FC<IconProps> = ({ svg, ...props }) => {
  const SVG = typeof svg === 'string' ? SVGs[svg] : svg;

  return (
    <Frame {...props}>
      <SVG />
    </Frame>
  );
};

/**
 * A component for rendering a pre-packaged SVG icon.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/core-icon--default}
 */
export default Object.assign(Icon, {
  Frame,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Icon/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.ICON);

export const Frame = styled(tag('div'), { display: 'flex' });


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Image/Default.tsx

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';
import type { VariantProp } from '@/types';

export const tag = tagFactory(ClassName.IMAGE);

export const DefaultImageBase = styled(tag('img'), {
  variants: {
    isRounded: {
      true: {
        borderRadius: '$1',
      },
    },
    mode: {
      overlay: {
        width: 248,
      },
      embedded: {
        width: '100%',
        maxWidth: 512,
      },
    },
  },
  defaultVariants: {
    isRounded: true,
    mode: 'overlay',
  },
});

export interface DefaultImageProps extends React.ComponentProps<typeof DefaultImageBase> {
  /**
   * A URL for the image to render.
   */
  image: string | null;

  /**
   * If true, rounds the corners of the image border.
   *
   * @default true
   */
  isRounded?: VariantProp<typeof DefaultImageBase, 'isRounded'>;
}

const DefaultImage: React.FC<DefaultImageProps> = ({ image, ...props }) => (
  <DefaultImageBase {...props} src={image || undefined} />
);

/**
 * An image rendered as the `src` of an `<img>`.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/core-image--round-corners}
 */
export default Object.assign(DefaultImage, { Base: DefaultImageBase });


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Image/Image.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import { MOCK_IMAGE } from '@/fixtures';

import Image from '.';

type Story = StoryObj<typeof Image>;

const meta: Meta<typeof Image> = {
  title: 'Core/Image',
  component: Image,
  args: {
    image: MOCK_IMAGE,
    isRounded: true,
  },
};

export default meta;

export const RoundCorners: Story = {};

export const StraightCorners: Story = {
  args: {
    isRounded: false,
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Image/index.tsx

import Default from './Default';

export default Default;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Input/Input.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Input from '.';

type Story = StoryObj<typeof Input>;

const meta: Meta<typeof Input> = {
  title: 'Core/Input',
  component: Input,
  args: {
    value: '',
    placeholder: '',
  },
  parameters: {
    controls: { include: ['value', 'placeholder', 'onValueChange'] },
  },
  render: (args) => <Input.Controlled {...args} />,
};

export default meta;

export const Default: Story = {};

export const WithPlaceholder: Story = {
  args: {
    placeholder: 'Messageâ€¦',
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Input/index.tsx

import type { Merge } from 'type-fest';

import type { ControlProps } from '@/utils/controls';
import { createControlled } from '@/utils/controls';
import { chain } from '@/utils/functional';

import { Container } from './styled';

export interface InputProps extends Merge<React.ComponentProps<typeof Container>, ControlProps<string>> {}

const Input: React.FC<InputProps> = ({ onValueChange, onChange, ...props }) => {
  const handleChange = chain(onChange, (event) => onValueChange(event.target.value));

  return <Container {...props} onChange={handleChange} />;
};

/**
 * A text input form control.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/core-input--default}
 */
export default Object.assign(Input, {
  Controlled: createControlled(Input, { defaultValue: '' }),
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Input/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import type { CSS } from '@/styles';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.INPUT);

export const inputStyles: CSS = {
  height: '$md',
  boxSizing: 'border-box',
  border: '1px solid rgba(115,115,118,0.3)',
  borderRadius: '$1',
  backgroundColor: '$white',
  boxShadow: '0 1px 12px $shadow2',
  trans: ['border-color'],
};

export const inputFocusStyles: CSS = {
  border: '1px solid rgba(115,115,118,0.5)',
};

export const Container = styled(tag('input'), {
  ...inputStyles,
  padding: '0 $4',
  typo: {},
  color: '$black',

  '&:focus': {
    ...inputFocusStyles,
    outline: 0,
  },

  '&::placeholder': {
    color: '$darkGrey',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Launcher/Launcher.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Launcher from '.';

type Story = StoryObj<typeof Launcher>;

const meta: Meta<typeof Launcher> = {
  title: 'Components/Launcher',
  component: Launcher,
  parameters: {
    controls: { hideNoControlsWarning: true },
  },
};

export default meta;

export const Default: Story = {};

export const IconOverride: Story = {
  args: {
    // eslint-disable-next-line no-secrets/no-secrets
    image: 'https://cm4-production-assets.s3.amazonaws.com/1668625107157-vf-nobg.png',
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Launcher/index.tsx

import type { MouseEventHandler } from 'react';
import React from 'react';

import launch from './launch.svg';
import { Button } from './styled';

export interface LauncherProps {
  /**
   * An image URL to be rendered as the icon.
   * Defaults to the "launch" SVG if not provided.
   */
  image?: string | undefined;

  /**
   * A callback that will be executed when the button is clicked.
   */
  onClick: MouseEventHandler<HTMLButtonElement>;
}

const Launcher: React.FC<LauncherProps> = ({ image, onClick }) => {
  return (
    <Button onClick={onClick}>
      <img src={image || launch} alt="launch" />
    </Button>
  );
};

/**
 * A floating action button used to launch the chat widget.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-launcher--default}
 */
export default Launcher;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Launcher/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.LAUNCHER);

export const Button = styled(tag('button'), {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  borderRadius: '$round',
  backgroundColor: '$primary',
  trans: ['background-color', 'box-shadow'],

  height: '$xl',
  width: '$xl',
  border: '1px solid $shadow4',
  boxShadow: '0 1px 6px $shadow6, 0 2px 24px $shadow8',

  '&:focus': {
    outline: 0,
  },
  '&:hover': {
    cursor: 'pointer',
    backgroundColor: '$darkPrimary',
  },

  '& > img': {
    width: '$sm',
    height: '$sm',
  },

  padding: 0,
  margin: 0,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Loader/Loader.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Loader from '.';

type Story = StoryObj<typeof Loader>;

const meta: Meta<typeof Loader> = {
  title: 'Core/Loader',
  component: Loader,
  parameters: {
    controls: { hideNoControlsWarning: true },
  },
};
export default meta;

export const Default: Story = {};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Loader/index.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { rotate, styled } from '@/styles';

const SIZE = 32;
const ANIMATION_DURATION = 1000;

const tag = tagFactory(ClassName.LOADER);

const Loader = styled(tag('div'), {
  height: SIZE,
  width: SIZE,
  borderWidth: '2px',
  borderStyle: 'solid',
  borderRadius: '$round',
  borderColor: '#f0f0f0',
  borderTopColor: '#000',
  animation: `${rotate} ${ANIMATION_DURATION}ms linear`,
  animationIterationCount: 'infinite',
});

/**
 * An infinite loading spinner.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/core-loader--default}
 */
export default Loader;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/MainMenuButton/MainMenuButton.tsx

import React, { useState } from 'react';
import { MainMenuButtonContainer, DropUpMenu } from './styled';
import Icon from '@/components/Icon'; // Import the Icon component for styling consistency

interface MainMenuButtonProps {
  onActionSelect: (action: string) => void;
}

const MainMenuButton: React.FC<MainMenuButtonProps> = ({ onActionSelect }) => {
  const [isOpen, setIsOpen] = useState(false);

  const handleMenuToggle = () => {
    setIsOpen((prev) => !prev);
  };

  const handleActionClick = (action: string) => {
    setIsOpen(false);
    onActionSelect(action);
  };

  return (
    <MainMenuButtonContainer>
      {/* Replace the button wrapper with Icon itself */}
      <Icon svg="plusCircle" onClick={handleMenuToggle} css={{ cursor: 'pointer', width: '24px', height: '24px' }} />
      {isOpen && (
        <DropUpMenu>
          <button onClick={() => handleActionClick('exploreTours')}>Explore Tours</button>
          <button onClick={() => handleActionClick('viewBookings')}>View Bookings</button>
          <button onClick={() => handleActionClick('contactSupport')}>Contact Support</button>
        </DropUpMenu>
      )}
    </MainMenuButtonContainer>
  );
};

export default MainMenuButton;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/MainMenuButton/index.tsx

export { default } from './MainMenuButton';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/MainMenuButton/styled.ts

import { styled } from '@/styles'; // Keep using the project-specific styling utility

export const MainMenuButtonContainer = styled('div', {
    position: 'relative',
    display: 'flex',
    alignItems: 'center', // Ensures the MainMenuButton is aligned vertically with other elements
    justifyContent: 'center',
    marginRight: '12px', // Adjust the spacing between the MainMenuButton and the ChatInput container to prevent collision
  });

export const DropUpMenu = styled('div', {
  position: 'absolute',
  bottom: 50,
  left: 0,
  backgroundColor: '$white',
  borderRadius: '$1',
  boxShadow: '0 1px 6px $shadow6',
  padding: '8px 0',
  width: 150,
  zIndex: 2,
  display: 'flex',
  flexDirection: 'column',

  '& button': {
    background: 'none',
    border: 'none',
    padding: '8px 16px',
    textAlign: 'left',
    cursor: 'pointer',
    color: '$black',

    '&:hover': {
      backgroundColor: '$lightGrey',
    },
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Message/ChatMessage.ts

import { styled } from '@/styles';

import { Container, tag } from './styled';

export const ChatMessage = styled(tag(Container, 'chat'), {
  variants: {
    from: {
      system: {
        color: '$black',
        backgroundColor: '$lightGrey',
      },

      user: {
        color: '$white',
        backgroundColor: '$primary',
        whiteSpace: 'break-spaces',
      },
    },
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Message/DebugMessage/index.tsx

import { topCaret as TopCaret } from '@/assets/svg';
import type { VariantProp } from '@/types';

import { Container } from './styled';

export interface DebugMessageProps extends React.PropsWithChildren {
  /**
   * The end of the message where the arrow is rendered.
   *
   * @default 'left'
   */
  orientation?: VariantProp<typeof Container, 'orientation'>;
}

const DebugMessage: React.FC<DebugMessageProps> = ({ children, ...props }) => (
  <Container {...props}>
    <TopCaret />
    {children}
  </Container>
);

export default Object.assign(DebugMessage, {
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Message/DebugMessage/styled.ts

import { styled } from '@/styles';

import { Container as BaseContainer, tag } from '../styled';

const CARET_HEIGHT = 6;
const OFFSET = 32;

export const Container = styled(tag(BaseContainer, 'debug'), {
  position: 'relative',
  marginTop: CARET_HEIGHT,
  border: '1px solid $medGrey',
  padding: '10px 14px',
  backgroundColor: '$white',
  boxShadow: '0 1px 2px $shadow2',

  svg: {
    position: 'absolute',
    top: -CARET_HEIGHT,
  },

  variants: {
    orientation: {
      left: {
        svg: {
          left: OFFSET,
        },
      },
      right: {
        svg: {
          right: OFFSET,
        },
      },
    },
  },
  defaultVariants: {
    orientation: 'left',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Message/Message.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Message from '.';

type Story = StoryObj<typeof Message>;

const meta: Meta<typeof Message> = {
  title: 'Core/Message',
  component: Message,
  argTypes: {
    variant: {
      options: Object.values(Message.Variant),
      control: { type: 'radio' },
      defaultValue: Message.Variant.CHAT,
    },
    from: {
      if: { arg: 'variant', eq: Message.Variant.CHAT },
      options: ['system', 'user'],
      control: { type: 'radio' },
      defaultValue: 'system',
    },
    orientation: {
      if: { arg: 'variant', eq: Message.Variant.DEBUG },
      options: ['left', 'right'],
      control: { type: 'radio' },
      defaultValue: 'left',
    },
  },
  args: {
    children: 'Lorem ipsum dolor sit amet consectetur adipisicing elit.',
  },
};

export default meta;

export const SystemChat: Story = {
  args: {
    variant: Message.Variant.CHAT,
    from: 'system',
  },
};

export const UserChat: Story = {
  args: {
    variant: Message.Variant.CHAT,
    from: 'user',
  },
};

export const DebugLeft: Story = {
  args: {
    variant: Message.Variant.DEBUG,
    orientation: 'left',
  },
};

export const DebugRight: Story = {
  args: {
    variant: Message.Variant.DEBUG,
    orientation: 'right',
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Message/constants.ts

export enum MessageVariant {
  CHAT = 'chat',
  DEBUG = 'debug',
}


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Message/index.ts

import { bindVariants } from '@/utils/variants';

import { ChatMessage } from './ChatMessage';
import { MessageVariant } from './constants';
import DebugMessage from './DebugMessage';
import { Container } from './styled';

const VARIANTS = {
  [MessageVariant.CHAT]: ChatMessage,
  [MessageVariant.DEBUG]: DebugMessage,
};

const Message = bindVariants(VARIANTS, MessageVariant.CHAT);

export default Object.assign(Message, {
  Variant: MessageVariant,

  Container,
  Chat: ChatMessage,
  Debug: DebugMessage,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Message/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

export const tag = tagFactory(ClassName.MESSAGE);

export const Container = styled(tag('div'), {
  display: 'inline-block',
  boxSizing: 'border-box',
  padding: '10px 14px',
  borderRadius: '$1',
  typo: {},
  overflowWrap: 'anywhere',
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Proactive/Close.tsx

import React from 'react';

import Icon from '@/components/Icon';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

export const tag = tagFactory(ClassName.PROACTIVE_CLOSE);

export const CloseContainer = styled(tag('div'), {
  width: 32,
  height: 32,
  borderRadius: '$round',
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  color: '#656D75',
  cursor: 'pointer',
  background: '$white',
  boxShadow: '$surfaceZ1Light',

  [`& ${Icon.Frame}`]: {
    width: 10,
    height: 10,
  },

  '&:hover, &:active': {
    color: '#2B3239',
  },
});

const Close: React.FC<React.ComponentProps<typeof CloseContainer>> = ({ ...props }) => (
  <CloseContainer {...props}>
    <Icon svg="closeV2" />
  </CloseContainer>
);

export default Close;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Proactive/Message.tsx

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

export const tag = tagFactory(ClassName.PROACTIVE_MESSAGE);

export const MessageContainer = styled(tag('div'), {
  padding: '11px 16px 10px 16px',
  maxWidth: 256,
  color: '#1A1E23',
  boxShadow: '$surfaceZ1Light',
  borderRadius: '$2',
  background: '$white',
  typo: { size: 14 },
});

export default MessageContainer;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Proactive/index.tsx

import { Trace } from '@voiceflow/base-types';
import React from 'react';
import { match } from 'ts-pattern';

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { animationStyles, styled } from '@/styles';
import { ChatPosition } from '@/types';

import Close, { CloseContainer } from './Close';
import Message, { MessageContainer } from './Message';

export const tag = tagFactory(ClassName.PROACTIVE);

export const ProactiveMessageContainer = styled('div', {
  display: 'flex',
  flexDirection: 'column',
  gap: 8,
  margin: '$4 0',
  alignItems: 'inherit',

  [`& ${MessageContainer}`]: {
    ...animationStyles({ duration: 150, delay: 0 }),
  },
});

export const ProactiveContainer = styled(tag('div'), {
  position: 'absolute',
  bottom: '100%',
  width: 256,
  display: 'flex',
  flexDirection: 'column',

  [`& ${CloseContainer}`]: {
    opacity: 0,
  },

  '&:hover': {
    [`& ${CloseContainer}`]: {
      opacity: 1,
    },
  },
});

interface ProactiveQueueProps {
  side: ChatPosition;
  messages: Trace.AnyTrace[];
}

const ProactiveQueue: React.FC<ProactiveQueueProps> = ({ side, messages }) => {
  const [isClosed, setIsClosed] = React.useState(false);

  const queue = React.useMemo(
    () =>
      messages.map((message, index) =>
        match(message)
          .with({ type: Trace.TraceType.TEXT }, ({ payload }) => (
            <Message key={index}>{String(payload.message)}</Message>
          ))
          .otherwise(() => null)
      ),
    [messages]
  );

  React.useEffect(() => {
    if (!queue.length) return;
    setIsClosed(false);
  }, [queue]);

  if (isClosed || !queue.length) return null;

  return (
    <ProactiveContainer style={{ [side]: 0, alignItems: side === ChatPosition.LEFT ? 'start' : 'end' }}>
      <Close onClick={() => setIsClosed(true)} />
      <ProactiveMessageContainer>{queue}</ProactiveMessageContainer>
    </ProactiveContainer>
  );
};

export default Object.assign(ProactiveQueue, {
  Message,
  Close,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Prompt/Prompt.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Chat from '@/components/Chat';

import Prompt from '.';

type Story = StoryObj<typeof Prompt>;

const meta: Meta<typeof Prompt> = {
  title: 'Components/Chat/Prompt',
  component: Prompt,
  args: {
    cancel: { label: 'Cancel' },
  },
  render: (args) => (
    <Chat.Container withPrompt>
      <div style={{ height: 250, backgroundColor: 'lavender' }} />
      <Prompt {...args} />
    </Chat.Container>
  ),
};

export default meta;

export const Base: Story = {
  args: {
    accept: { label: 'Primary Action' },
  },
};

export const Dangerous: Story = {
  args: {
    accept: { label: 'Dangerous Action', type: 'warn' },
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Prompt/index.tsx

import Button from '@/components/Button';

import { Container } from './styled';

export interface PromptOptionProps extends React.ComponentProps<typeof Button.Primary> {
  /**
   * The label that will appear on the action button.
   */
  label: string;
}

export interface PromptProps {
  /**
   * Configuration for the "accept" action.
   */
  accept: PromptOptionProps;

  /**
   * Configuration for the "cancel" action.
   */
  cancel: PromptOptionProps;
}

const Prompt: React.FC<PromptProps> = ({ accept, cancel }) => (
  <Container>
    <Button.Primary tabIndex={-1} {...accept}>
      {accept.label}
    </Button.Primary>
    <Button type="subtle" tabIndex={-1} {...cancel}>
      {cancel.label}
    </Button>
  </Container>
);

/**
 * A popup that prompts the user with cancel and accept actions.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-chat-prompt--default}
 */
export default Object.assign(Prompt, {
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Prompt/styled.ts

import Button from '@/components/Button';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.PROMPT);

export const Container = styled(tag('div'), {
  padding: '$4 $4 $3 $4',
  borderRadius: '$1',
  backgroundColor: '$white',
  boxShadow: '0 12px 48px 4px $shadow12',

  [`& ${Button.Container}`]: {
    width: '100%',
    marginTop: '$1',

    '&:first-of-type': {
      marginTop: 0,
    },
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/ExtensionMessage.tsx

import type { Trace } from '@voiceflow/base-types';
import { useEffect, useRef } from 'react';

import type { ResponseExtension } from '@/dtos/Extension.dto';

import Message from '../Message';

export interface ExtensionMessageProps {
  extension: ResponseExtension;
  trace: Trace.AnyTrace;
}

export const ExtensionMessage: React.FC<ExtensionMessageProps> = ({ extension, trace }) => {
  const ref = useRef<HTMLSpanElement>(null);

  useEffect(() => {
    try {
      const unmount = extension.render?.({ trace, element: ref.current as HTMLElement });
      if (!unmount) return undefined;

      return () => {
        try {
          unmount?.();
        } catch (e) {
          console.error(`Extension '${extension.name}' threw an error while unmounting: ${e}`);
        }
      };
    } catch (e) {
      console.error(`Extension '${extension.name}' threw an error while mounting: ${e}`);
      return undefined;
    }
  }, []);

  return (
    <Message from="system" className={`vfrc-message--extension-${extension.name}`}>
      <span ref={ref} />
    </Message>
  );
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/Indicator.tsx

import Avatar from '@/components/Avatar';
import TypingIndicator from '@/components/TypingIndicator';

import { IndicatorContainer } from './styled';

export interface IndicatorProps {
  avatar: string;
}

const Indicator: React.FC<IndicatorProps> = ({ avatar }) => (
  <IndicatorContainer withImage center>
    <Avatar avatar={avatar} />
    <TypingIndicator />
  </IndicatorContainer>
);

export default Indicator;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/SystemMessage.tsx

import { useContext, useRef } from 'react';
import * as R from 'remeda';
import { match } from 'ts-pattern';

import Avatar from '@/components/Avatar';
import Card from '@/components/Card';
import Carousel from '@/components/Carousel';
import Image from '@/components/Image';
import Text from '@/components/Text';
import Timestamp from '@/components/Timestamp';
import { RuntimeStateAPIContext } from '@/contexts';

import type { FeedbackProps } from '../Feedback';
import Feedback from '../Feedback';
import { MessageType } from './constants';
import { ExtensionMessage } from './ExtensionMessage';
import EndState from './state/end';
import { Controls, List, MessageContainer } from './styled';
import type { MessageProps } from './types';

export interface SystemMessageProps extends React.PropsWithChildren {
  /**
   * An image URL for an avatar to associate this message with.
   */
  avatar: string;

  /**
   * A unix timestamp indicating when this message was sent.
   */
  timestamp: number;

  /**
   * A single message to render.
   */
  message?: MessageProps;

  /**
   * If true, renders an avatar next to the message.
   */
  withImage: boolean;

  /**
   * If provided, will display {@link Feedback} component.
   * @default false
   */
  feedback?: FeedbackProps | undefined;
}

const SystemMessage: React.FC<SystemMessageProps> = ({ avatar, feedback, timestamp, message, withImage, children }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const controlsRef = useRef<HTMLSpanElement>(null);

  const { config } = useContext(RuntimeStateAPIContext);

  if (!children && message?.type === MessageType.END) {
    return <EndState />;
  }

  return (
    <>
      <Controls ref={controlsRef} />
      <MessageContainer ref={containerRef} withImage={withImage} scrollable={message?.type === MessageType.CAROUSEL}>
        <Avatar avatar={avatar} />
        <List>
          {children ??
            match(message)
              .with({ type: MessageType.TEXT }, ({ text }) => <Text text={text} />)
              .with({ type: MessageType.IMAGE }, ({ url }) => <Image image={url} mode={config.render?.mode} />)
              .with({ type: MessageType.CARD }, (props) => <Card {...R.omit(props, ['type'])} />)
              .with({ type: MessageType.CAROUSEL }, (props) => (
                <Carousel {...R.omit(props, ['type'])} containerRef={containerRef} controlsRef={controlsRef} />
              ))
              .with({ type: MessageType.EXTENSION }, ({ payload }) => (
                <ExtensionMessage extension={payload.extension} trace={payload.trace} />
              ))
              .otherwise(() => null)}
          {feedback && <Feedback {...feedback} />}
        </List>
        <Timestamp value={timestamp} />
      </MessageContainer>
    </>
  );
};

/**
 * An individual message within a system response.
 */
export default SystemMessage;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/SystemResponse.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Chat from '@/components/Chat';
import { MOCK_IMAGE, VF_ICON } from '@/fixtures';

import type { MessageProps } from '.';
import SystemResponse from '.';

type Story = StoryObj<typeof SystemResponse>;

const CARD_IMAGE = MOCK_IMAGE;
const TEXT_MESSAGE: MessageProps = {
  type: 'text',
  text: 'Lorem ipsum dolor sit amet consectetur voluptas perspiciatis est quis dolores',
};
const CARD: MessageProps = {
  type: 'card',
  title: 'Card Message',
  description:
    'Lorem ipsum dolor sit amet consectetur adipisicing elit. Exercitationem voluptas perspiciatis est quis dolores!',
  image: CARD_IMAGE,
};

const meta: Meta<typeof SystemResponse> = {
  title: 'Components/Chat/SystemResponse',
  component: SystemResponse,
  args: {
    timestamp: Date.now(),
    avatar: VF_ICON,
    isLast: false,
  },
  argTypes: {
    timestamp: {
      control: { type: 'date' },
    },
  },
  excludeStories: ['RawTemplate'],
  render: (args) => (
    <Chat.Container>
      <Chat.Dialog css={{ padding: '64px 0', display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
        <SystemResponse {...args} />
      </Chat.Dialog>
    </Chat.Container>
  ),
};

export default meta;

export const SimpleText: Story = {
  args: {
    messages: [{ type: 'text', text: 'Lorem ipsum dolor' }],
  },
};

export const WrappingText: Story = {
  args: {
    messages: [{ type: 'text', text: 'consecteturaconsecteturaconsecteturaconsecteturaconsecteturaconsectetura' }],
  },
};

export const MultilineText: Story = {
  args: {
    messages: [TEXT_MESSAGE],
  },
};

export const ActionableText: Story = {
  args: {
    messages: [TEXT_MESSAGE, TEXT_MESSAGE, TEXT_MESSAGE],
    isLast: true,
    actions: [
      { request: {} as any, name: 'Button One' },
      { request: {} as any, name: 'Button Two' },
      { request: {} as any, name: 'Button Three' },
    ],
  },
};

export const Image: Story = {
  args: {
    messages: [{ type: 'image', url: CARD_IMAGE }],
  },
};

export const Card: Story = {
  args: {
    messages: [CARD],
  },
};

export const ActionableCard: Story = {
  args: {
    messages: [
      {
        ...CARD,
        actions: [
          { request: {} as any, name: 'First Button' },
          { request: {} as any, name: 'Second Button' },
          { request: {} as any, name: 'Third Button' },
        ],
      },
    ],
  },
};

export const Carousel: Story = {
  args: {
    messages: [
      {
        type: 'carousel',
        cards: [
          {
            title: 'First Card',
            description:
              'Lorem ipsum dolor sit amet consectetur adipisicing elit. Exercitationem voluptas perspiciatis est quis dolores!',
            image: CARD_IMAGE,
            actions: [
              { request: {} as any, name: 'First Button' },
              { request: {} as any, name: 'Second Button' },
              { request: {} as any, name: 'Third Button' },
            ],
          },
          {
            title: 'Second Card',
            description: 'Lorem ipsum dolor sit amet consectetur adipisicing elit.',
            image: CARD_IMAGE,
            actions: [
              { request: {} as any, name: 'First Button' },
              { request: {} as any, name: 'Second Button' },
            ],
          },
          {
            title: 'Third Card',
            description: 'Lorem ipsum dolor sit amet',
            image: CARD_IMAGE,
          },
        ],
      },
    ],
  },
};

export const Multiple: Story = {
  args: {
    messages: [CARD, TEXT_MESSAGE],
  },
};

export const MultipleWithFeedback: Story = {
  args: {
    feedback: {
      onClick: () => null,
    },
    messages: [CARD, TEXT_MESSAGE],
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/constants.ts

export enum MessageType {
  TEXT = 'text',
  IMAGE = 'image',
  CARD = 'card',
  CAROUSEL = 'carousel',
  END = 'END',
  EXTENSION = 'EXTENSION',
}

export const DEFAULT_MESSAGE_DELAY = 1000;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/hooks.ts

import { useCallback, useEffect, useRef, useState } from 'react';
import { match } from 'ts-pattern';

import { useDidUpdateEffect } from '@/hooks';

import { DEFAULT_MESSAGE_DELAY } from './constants';
import type { MessageProps } from './types';

export * from './types';

enum AnimationType {
  MESSAGE = 'message',
  INDICATOR = 'indicator',
}

type Animation<T extends AnimationType = AnimationType> = {
  [AnimationType.MESSAGE]: { type: AnimationType.MESSAGE; message: MessageProps };
  [AnimationType.INDICATOR]: { type: AnimationType.INDICATOR; messageDelay: number };
}[T];

const createAnimateIndicator = (messageDelay: number = DEFAULT_MESSAGE_DELAY): Animation<AnimationType.INDICATOR> => ({
  type: AnimationType.INDICATOR,
  messageDelay,
});

export const useAnimatedMessages = ({
  messages,
  isLast,
}: {
  messages: MessageProps[];
  isLast: boolean | undefined;
}) => {
  const shouldAnimate = useRef(isLast && !!messages.length);
  const [complete, setComplete] = useState(!shouldAnimate.current);
  const [showIndicator, setShowIndicator] = useState(shouldAnimate.current);
  const [visibleMessages, setVisibleMessages] = useState(shouldAnimate.current ? [] : messages);

  const endAnimation = useCallback(() => {
    setComplete(true);
    setShowIndicator(false);
  }, []);

  useEffect(() => {
    if (!shouldAnimate) return undefined;

    const animations = messages.flatMap<Animation>((message) => [
      createAnimateIndicator(message.delay),
      { type: AnimationType.MESSAGE, message },
    ]);

    let timer: NodeJS.Timeout;
    const setTimer = (callback: VoidFunction, messageDelay: number) => {
      if (messageDelay === 0) {
        callback();
        return;
      }

      timer = setTimeout(() => {
        callback();
      }, messageDelay);
    };

    const animate = () => {
      if (!shouldAnimate.current) return;

      const next = animations.shift();
      if (!next) {
        endAnimation();
        return;
      }

      match(next)
        .with({ type: AnimationType.MESSAGE }, ({ message }) => {
          setShowIndicator(false);
          setVisibleMessages((prev) => [...prev, message]);
          setTimer(animate, DEFAULT_MESSAGE_DELAY);
        })
        .with({ type: AnimationType.INDICATOR }, ({ messageDelay = DEFAULT_MESSAGE_DELAY }) => {
          setShowIndicator(true);
          setTimer(animate, messageDelay);
        })
        .exhaustive();
    };

    animate();

    return () => {
      clearTimeout(timer);
    };
  }, []);

  useDidUpdateEffect(() => {
    if (!isLast) {
      shouldAnimate.current = false;
      endAnimation();
      setVisibleMessages(messages);
    }
  }, [isLast]);

  return {
    complete,
    showIndicator,
    visibleMessages,
  };
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/index.tsx

import type { RuntimeAction } from '@voiceflow/sdk-runtime';
import { useContext } from 'react';

import Button from '@/components/Button';
import { RuntimeStateAPIContext } from '@/contexts';
import { useAutoScroll } from '@/hooks';

import type { FeedbackProps } from '../Feedback';
import Feedback from '../Feedback';
import { MessageType } from './constants';
import { useAnimatedMessages } from './hooks';
import Indicator from './Indicator';
import { Actions, Container, Controls, List } from './styled';
import type { SystemMessageProps } from './SystemMessage';
import SystemMessage from './SystemMessage';
import type { MessageProps } from './types';

export * from './types';

export interface ResponseActionProps {
  name: string;
  request: RuntimeAction;
}

export interface SystemResponseProps {
  /**
   * An image URL for an avatar to associate the messages with.
   */
  avatar: string;

  /**
   * A unix timestamp indicating when the messages were sent.
   */
  timestamp: number;

  /**
   * A list of messages that will be rendered as {@link SystemMessage} components.
   */
  messages: MessageProps[];

  /**
   * A list of actions that will be rendered as buttons.
   */
  actions?: ResponseActionProps[];

  /**
   * If true, allows actions to appear after this message.
   * Only the last system message in a row can show actions.
   */
  isLast?: boolean;

  /**
   * If provided, will display {@link Feedback} component under the last message.
   * @default false
   */
  feedback?: FeedbackProps | undefined;

  /**
   * Override the rendering of individual messages.
   */
  Message?: React.ComponentType<SystemMessageProps>;
}

const SystemResponse: React.FC<SystemResponseProps> = ({
  feedback,
  avatar,
  timestamp,
  messages,
  actions = [],
  isLast,
  Message = SystemMessage,
}) => {
  const runtime = useContext(RuntimeStateAPIContext);

  const { showIndicator, visibleMessages, complete } = useAnimatedMessages({
    messages,
    isLast,
  });

  useAutoScroll([showIndicator, complete, visibleMessages.length]);

  if (!messages.length && !actions.length) return null;

  return (
    <>
      {visibleMessages.map((message, index) => (
        <Message
          message={message}
          withImage={!showIndicator && index === visibleMessages.length - 1}
          feedback={complete && !showIndicator && index === visibleMessages.length - 1 ? feedback : undefined}
          avatar={avatar}
          timestamp={timestamp}
          key={index}
        />
      ))}

      {isLast && complete && !!actions.length && (
        <Actions>
          {actions.map(({ request, name }, index) => (
            <Button variant="secondary" onClick={() => runtime?.interact(request, name)} key={index}>
              {name}
            </Button>
          ))}
        </Actions>
      )}

      {showIndicator && <Indicator avatar={avatar} />}
    </>
  );
};

/**
 * A dynamic component capable of displaying all standard system responses.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-chat-systemresponse--simple-text}
 */
export default Object.assign(SystemResponse, {
  Message: MessageType,

  Container,
  Controls,
  List,
  Actions,
  Indicator,
  SystemMessage,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/state/end.tsx

import { useContext, useEffect } from 'react';

import { RuntimeStateAPIContext } from '@/contexts';
import { SessionStatus } from '@/types';

const EndState: React.FC = () => {
  const runtime = useContext(RuntimeStateAPIContext);

  useEffect(() => {
    runtime.setStatus(SessionStatus.ENDED);
  }, []);

  return null;
};

export default EndState;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/styled.ts

import Avatar from '@/components/Avatar';
import Button from '@/components/Button';
import Message from '@/components/Message';
import Timestamp from '@/components/Timestamp';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.SYSTEM_RESPONSE);

export const Actions = styled(tag('div', 'actions'), {
  display: 'flex',
  flexWrap: 'wrap',
  marginBottom: 8,
  padding: '0 $5 0 54px',

  [`& ${Button.Container}`]: {
    height: 'unset',
    paddingTop: 7,
    paddingBottom: 7,
    marginTop: 8,
    marginRight: 8,
    whiteSpace: 'normal',
    textAlign: 'start',
  },
});

export const Controls = styled(tag('span', 'controls'), {
  position: 'relative',
});

export const Container = styled(tag('div'), {
  display: 'flex',

  [`& ${Avatar.Container}`]: {
    visibility: 'hidden',
    alignSelf: 'flex-end',
    margin: '0 8px 4px 0',
  },

  [`& ${Timestamp.Container}`]: {
    alignSelf: 'center',
    whiteSpace: 'nowrap',
    marginLeft: 8,
    opacity: '0%',
    trans: ['opacity'],
  },

  [`&:hover ${Timestamp.Container}`]: {
    opacity: '100%',
  },

  variants: {
    withImage: {
      true: {
        [`& ${Avatar.Container}`]: {
          visibility: 'visible',
        },
      },
    },
    scrollable: {
      true: {
        overflowX: 'scroll',
        flexShrink: 0,
        scrollbarWidth: 'none',
        '-ms-overflow-style': 'none',

        '&::-webkit-scrollbar': {
          display: 'none',
        },
      },
    },
    center: {
      true: {
        alignItems: 'center',
      },
    },
  },
});

export const MessageContainer = styled(tag(Container, 'message'));

export const IndicatorContainer = styled(tag(Container, 'indicator'));

export const List = styled(tag('div', 'list'), {
  display: 'flex',
  flexDirection: 'column',
  flexShrink: 0,
  flex: 'inherit',

  [`& ${Message.Container}`]: {
    marginBottom: '$1',

    '&:last-of-type': {
      marginBottom: 0,
    },
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/SystemResponse/types.ts

import type { Text, Trace } from '@voiceflow/base-types';

import type { CardProps } from '@/components/Card/types';
import type { ResponseExtension } from '@/dtos/Extension.dto';
import type { StringifiedEnum } from '@/types/util';

import type { MessageType } from './constants';

export interface BaseMessageProps {
  delay?: number | undefined;
  ai?: boolean;
}

export interface TextMessageProps extends BaseMessageProps {
  type: StringifiedEnum<MessageType.TEXT>;
  text: string | Text.SlateTextValue;
  audio?: { src: string };
}

export interface ImageMessageProps extends BaseMessageProps {
  type: StringifiedEnum<MessageType.IMAGE>;
  url: string | null;
}

export interface CardMessageProps extends CardProps, BaseMessageProps {
  type: StringifiedEnum<MessageType.CARD>;
}

export interface CarouselMessageProps extends BaseMessageProps {
  type: StringifiedEnum<MessageType.CAROUSEL>;
  cards: CardProps[];
}

export interface EndMessage extends BaseMessageProps {
  type: StringifiedEnum<MessageType.END>;
}

export interface ExtensionMessage extends BaseMessageProps {
  type: StringifiedEnum<MessageType.EXTENSION>;
  payload: {
    trace: Trace.AnyTrace;
    extension: ResponseExtension;
  };
}

export interface CustomMessage extends BaseMessageProps {
  type: `custom_${string}`;
  payload: any;
}

export type MessageProps =
  | TextMessageProps
  | ImageMessageProps
  | CardMessageProps
  | CarouselMessageProps
  | EndMessage
  | ExtensionMessage
  | CustomMessage;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Text/Default.tsx

import { serializeToMarkdown } from '@voiceflow/slate-serializer/markdown';
import React from 'react';
import rehypeRaw from 'rehype-raw';

import Message from '@/components/Message';
import type { TextMessageProps } from '@/components/SystemResponse/types';
import { RuntimeStateAPIContext } from '@/contexts';

import Markdown from './Markdown';

export interface DefaultTextProps {
  /**
   * text whether in string or slate format
   */
  text: TextMessageProps['text'];
}

// this is just eslint being dumb because "allowDangerousHTML" contains "HTML"
const DefaultText: React.FC<DefaultTextProps> = ({ text }) => {
  const api = React.useContext(RuntimeStateAPIContext);

  const content = typeof text === 'string' ? text : serializeToMarkdown(text);

  if (api?.config?.allowDangerousHTML) {
    return (
      <Message from="system">
        <Markdown rehypePlugins={[rehypeRaw]}>{content}</Markdown>
      </Message>
    );
  }

  return (
    <Message from="system">
      <Markdown>{content}</Markdown>
    </Message>
  );
};

// memoize to prevent re-rendering
export default React.memo(DefaultText);


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Text/Markdown.tsx

import { PureComponent } from 'react';
import type { Options } from 'react-markdown';
import ReactMarkdown from 'react-markdown';
import rehypeRaw from 'rehype-raw';
import rehypeSanitize from 'rehype-sanitize';
import remarkGfm from 'remark-gfm';

import { styled } from '@/styles';

import { schema, transformURL } from './schema';

const MarkdownText = styled(ReactMarkdown, {
  blockquote: {
    marginLeft: 0,
    paddingLeft: '$4',
    borderLeft: '3px solid $medGrey',
  },
  code: {
    color: '#e83e8c',
    whiteSpace: 'pre-wrap',
  },
  p: {
    marginTop: 0,
    whiteSpace: 'pre-wrap',
  },
  'img,video': {
    maxWidth: '100%',
    borderRadius: '$2',
    marginBottom: '$4',
  },
  'ol,ul': {
    paddingInlineStart: '$5',
  },
  '> *:first-child, blockquote>:first-child': {
    marginTop: 0,
  },
  '> *:last-child, blockquote>:last-child': {
    marginBottom: 0,
  },
});

MarkdownText.defaultProps = {
  urlTransform: transformURL,
  rehypePlugins: [rehypeRaw, [rehypeSanitize, schema]],
  remarkPlugins: [remarkGfm],
  components: {
    a: ({ node, href, children, ...props }) => (
      <a href={href} target="_blank" rel="noopener noreferrer" {...props}>
        {children}
      </a>
    ),
  },
  remarkRehypeOptions: {
    handlers: {
      break: () => [{ type: 'text', value: '\n' }],
    },
  },
};

class Markdown extends PureComponent<Options> {
  state = {
    hasError: false,
  };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidUpdate(prevProps: Readonly<Options>): void {
    if (prevProps.children !== this.props.children) {
      this.setState({ hasError: false });
    }
  }

  componentDidCatch(error: unknown, errorInfo: unknown) {
    console.error(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <>Couldn't render markdown.</>;
    }

    return <MarkdownText {...this.props} />;
  }
}

export default Markdown;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Text/index.tsx

import Default from './Default';

export { default as Markdown } from './Markdown';

export default Default;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Text/schema.ts

import { defaultSchema } from 'rehype-sanitize';

const mediaAttributes = ['controls', 'src', 'type', 'autoPlay', 'loop', 'muted', 'playsInline', 'poster'];

export const schema = {
  ...defaultSchema,
  attributes: {
    ...defaultSchema.attributes,
    video: mediaAttributes,
    audio: mediaAttributes,
    '*': [...defaultSchema.attributes!['*'], 'style'],
  },
  protocols: {
    ...defaultSchema.protocols,
    poster: ['https'],
  },
  tagNames: [...defaultSchema.tagNames!, 'video', 'audio'],
};

const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
export function transformURL(value: string): string {
  const colon = value.indexOf(':');
  const questionMark = value.indexOf('?');
  const numberSign = value.indexOf('#');
  const slash = value.indexOf('/');

  if (
    // If there is no protocol, itâ€™s relative.
    colon < 0 ||
    // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.
    (slash > -1 && colon > slash) ||
    (questionMark > -1 && colon > questionMark) ||
    (numberSign > -1 && colon > numberSign) ||
    // It is a protocol, it should be allowed.
    safeProtocol.test(value.slice(0, colon))
  ) {
    return value;
  }

  return '';
}


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Textarea/Textarea.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Textarea from '.';

type Story = StoryObj<typeof Textarea>;
const meta: Meta<typeof Textarea> = {
  title: 'Core/Textarea',
  component: Textarea,
  args: {
    value: 'Message text',
    onChange: () => null,
  },
};

export default meta;

export const Base: Story = {
  args: {
    value: 'Message text',
  },
};

export const Disabled: Story = {
  args: {
    value: 'Message text',
    disabled: true,
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Textarea/index.tsx

import type { ForwardRefExoticComponent, RefAttributes } from 'react';
import { forwardRef } from 'react';
import type { TextareaAutosizeProps } from 'react-textarea-autosize';
import type { Merge } from 'type-fest';

import type { ControlProps } from '@/utils/controls';
import { createControlled } from '@/utils/controls';
import { chain } from '@/utils/functional';

import { Container } from './styled';

export interface TextareaProps extends Merge<ControlProps<string>, Omit<TextareaAutosizeProps, 'value' | 'rows'>> {}

const Textarea: ForwardRefExoticComponent<TextareaProps & RefAttributes<HTMLTextAreaElement>> = forwardRef<
  HTMLTextAreaElement,
  TextareaProps
>(({ onValueChange, onChange, ...props }, ref) => {
  const handleChange = chain(onChange, (event) => onValueChange(event.target.value));
  return <Container ref={ref} {...props} onChange={handleChange} minRows={1} maxRows={5} style={{ height: 42 }} />;
});

/**
 * A textarea form control.
 */
export default Object.assign(Textarea, {
  Controlled: createControlled(Textarea as any, { defaultValue: '' }),
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Textarea/styled.ts

import TextareaAutosize from 'react-textarea-autosize';

import type { CSS } from '@/styles';
import { styled } from '@/styles';

export const textareaUniqueStyles: CSS = {
  width: 'calc(100% - 42px)',
  borderRadius: '$1 0 0 $1',
  height: '42px',
  borderRightWidth: 0,
  fontFamily: '$default',
  fontSize: '$2',
};

export const textareaStyles: CSS = {
  boxSizing: 'border-box',
  border: '1px solid rgba(115,115,118,0.3)',
  backgroundColor: '$white',
  boxShadow: '0 1px 12px $shadow2',
  trans: ['border-color'],
  resize: 'none',
};

export const textareaFocusStyles: CSS = {
  border: '1px solid rgba(115,115,118,0.5)',
};

export const Container = styled(TextareaAutosize, {
  ...textareaStyles,
  ...textareaUniqueStyles,
  // TODO use tokens
  padding: '11px $4 11px',
  color: '$black',

  '&:focus': {
    ...textareaFocusStyles,
    ...textareaUniqueStyles,
    outline: 'none',
  },

  '&::placeholder': {
    color: '$darkGrey',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Timestamp/Timestamp.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Timestamp from '.';

type Story = StoryObj<typeof Timestamp>;
const meta: Meta<typeof Timestamp> = {
  title: 'Core/Timestamp',
  component: Timestamp,
  argTypes: {
    value: { control: 'date' },
  },
};

export default meta;

export const Default: Story = {
  args: {
    value: new Date('2024-09-11T08:21:00.000Z').getTime(),
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Timestamp/index.tsx

import { formatTimestamp } from '@/components/Timestamp/utils';

import Container from './styled';

export interface TimestampProps {
  /**
   * A timestamp in milliseconds since unix epoch.
   */
  value: number;
}

const Timestamp: React.FC<TimestampProps> = ({ value }) => <Container>{formatTimestamp(value)}</Container>;

/**
 * Formats and styles a timestamp as 12-hour time.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/docs/core-timestamp--default}
 */
export default Object.assign(Timestamp, {
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Timestamp/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.TIMESTAMP);

const Container = styled(tag('div'), {
  typo: { size: 12, height: '17px' },
  color: '$darkGrey',
  whiteSpace: 'nowrap',
  flexShrink: 0,
});

export default Container;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Timestamp/utils.ts

export const formatTimestamp = (timestamp: number) => {
  const date = new Date(timestamp);
  const hours = date.getHours();
  const minutes = date.getMinutes();

  return `${hours % 12 || 12}:${minutes >= 10 ? '' : '0'}${minutes} ${hours >= 12 ? 'pm' : 'am'}`;
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Tooltip/Tooltip.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Tooltip from '.';

type Story = StoryObj<typeof Tooltip>;
const meta: Meta<typeof Tooltip> = {
  title: 'Components/Tooltip',
  component: Tooltip,
  argTypes: {
    onClick: { table: { disable: true } },
    orientation: {
      options: ['left', 'right'],
      control: { type: 'radio' },
      defaultValue: 'left',
    },
  },
  args: {
    children: 'Lorem ipsum dolor sit amet consectetur adipisicing elit.',
  },
};

export default meta;

export const LeftOrientation: Story = {
  args: {
    orientation: 'left',
  },
};

export const RightOrientation: Story = {
  args: {
    orientation: 'right',
  },
};

export const Actionable: Story = {
  args: {
    label: 'Action Label',
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Tooltip/index.tsx

import Message from '@/components/Message';

import type { DebugMessageProps } from '../Message/DebugMessage';
import { Button, Container } from './styled';

export interface ActionMessageProps extends DebugMessageProps {
  /**
   * If provided, this will render an action button within the tooltip.
   */
  label?: string | undefined;

  /**
   * A callback handler for the action button.
   */
  onClick?: React.MouseEventHandler<HTMLButtonElement> | undefined;
}

const ActionMessage: React.FC<ActionMessageProps> = ({ label, onClick, children, ...props }) => (
  <Container withAction={!!label}>
    <Message.Debug {...props}>{children}</Message.Debug>
    {label && <Button onClick={onClick}>{label}</Button>}
  </Container>
);

/**
 * Renders a {@link Message.Debug} with an optional action.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-tooltip--left-orientation}
 */
export default Object.assign(ActionMessage, {
  Button,
  Container,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/Tooltip/styled.ts

import BaseButton from '@/components/Button';
import Message from '@/components/Message';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

const tag = tagFactory(ClassName.TOOLTIP);

export const Button = styled(tag(BaseButton.Reset, 'button'), {
  height: '$md',
  border: '1px solid $medGrey',
  borderTopColor: 'rgba(223,223,223,0.5)',
  borderRadius: '$1',
  borderTopLeftRadius: 0,
  borderTopRightRadius: 0,
  typo: { weight: '$2' },
  color: '$primary',
  backgroundColor: '#fbfbfb',
});

export const Container = styled(tag('div'), {
  display: 'inline-flex',
  flexDirection: 'column',

  variants: {
    withAction: {
      true: {
        boxShadow: '0 1px 2px $shadow2',

        [`& ${Message.Debug.Container}`]: {
          boxShadow: 'none',
          borderBottom: 0,
          borderBottomLeftRadius: 0,
          borderBottomRightRadius: 0,
        },
      },
    },
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/TypingIndicator/TypingIndicator.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import TypingIndicator from '.';

type Story = StoryObj<typeof TypingIndicator>;
const meta: Meta<typeof TypingIndicator> = {
  title: 'Components/TypingIndicator',
  component: TypingIndicator,
  parameters: {
    controls: { hideNoControlsWarning: true },
  },
};

export default meta;

export const Default: Story = {};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/TypingIndicator/index.tsx

import { ANIMATION_DURATION, Container, Dot } from './styled';

const ANIMATION_DELAY = Math.floor(ANIMATION_DURATION / 3);

const TypingIndicator: React.FC = () => (
  <Container>
    {Array.from({ length: 3 }).map((_, index) => (
      <Dot css={{ animationDelay: `${ANIMATION_DELAY * (index + 1)}ms` }} key={index} />
    ))}
  </Container>
);

/**
 * An animated indicator to show that the system is preparing a response.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/docs/components-typingindicator--default}
 */
export default Object.assign(TypingIndicator, {
  Container,
  Dot,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/TypingIndicator/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { pulse, styled } from '@/styles';

export const ANIMATION_DURATION = 1000;

const tag = tagFactory(ClassName.TYPING_INDICATOR);

export const Container = styled(tag('span'), {
  display: 'inline-flex',
});

export const Dot = styled(tag('span', 'dot'), {
  height: 8,
  width: 8,
  margin: '0 2px',
  borderRadius: '$round',
  backgroundColor: '#adadb3',
  opacity: 0.2,
  animation: `${pulse} ${ANIMATION_DURATION}ms`,
  animationIterationCount: 'infinite',
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/UserResponse/UserResponse.story.tsx

import type { Meta, StoryObj } from '@storybook/react';

import Chat from '@/components/Chat';

import UserResponse from '.';

type Story = StoryObj<typeof UserResponse>;
const meta: Meta<typeof UserResponse> = {
  title: 'Components/Chat/UserResponse',
  component: UserResponse,
  args: {
    timestamp: Date.now(),
  },
  render: (args) => (
    <Chat.Container>
      <Chat.Dialog css={{ padding: '64px 0', display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
        <UserResponse {...args} />
      </Chat.Dialog>
    </Chat.Container>
  ),
};

export default meta;

export const PlainText: Story = {
  args: {
    message: 'Lorem ipsum dolor',
  },
};

export const Wrapping: Story = {
  args: {
    message:
      'consecteturaconse cteturaconsecteturaconsecteturaconsecteturaconsectetura consecteturaconsecteturaconsecteturaconsecteturaconsecteturaconsectetura',
  },
};

export const Debug: Story = {
  args: {
    message: 'Lorem ipsum dolor',
    debug: {
      message: 'Intent Name (97%)',
    },
  },
};

export const DebugReason: Story = {
  args: {
    message: 'Lorem ipsum dolor',
    debug: {
      message: 'Intent Name (97%)',
      reason: 'Voluptatum quae, accusamus excepturi inventore ex quos veritatis eaque ab non?',
    },
  },
};

export const ActionableDebugReason: Story = {
  args: {
    ...DebugReason.args,
    debug: {
      message: 'Intent Name (97%)',
      action: { label: 'Add Missing Utterance' },
    },
  },
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/UserResponse/index.tsx

import { useContext } from 'react';

import Message from '@/components/Message';
import Timestamp from '@/components/Timestamp';
import Tooltip from '@/components/Tooltip';
import { RuntimeStateAPIContext } from '@/contexts';
import { useAutoScroll } from '@/hooks';

import { Container, Debug, Row } from './styled';

export interface DebugActionProps {
  label: string;
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
}

export interface DebugResponseProps {
  message: string;
  reason?: string;
  action?: DebugActionProps;
}

export interface UserResponseProps {
  /**
   * The message text to display.
   */
  message: string;

  /**
   * A unix timestamp indicating when this response was sent.
   */
  timestamp: number;

  /**
   * If provided, adds a caption and optional "debug" message with an action.
   */
  debug?: DebugResponseProps;
}

const UserResponse: React.FC<UserResponseProps> = ({ message, timestamp, debug }) => {
  useAutoScroll();

  const { config } = useContext(RuntimeStateAPIContext);
  return (
    <Container mode={config.render.mode}>
      <Row>
        <Timestamp value={timestamp} />
        <Message from="user">{message}</Message>
      </Row>
      {debug && (
        <>
          <Debug>{debug.message}</Debug>
          {debug.reason && (
            <Tooltip label={debug.action?.label} onClick={debug.action?.onClick} orientation="right">
              {debug.reason}
            </Tooltip>
          )}
        </>
      )}
    </Container>
  );
};

/**
 * A user-sent text response.
 *
 * @see {@link https://voiceflow.github.io/react-chat/?path=/story/components-chat-userresponse--simple}
 */
export default Object.assign(UserResponse, {
  Container,
  Debug,
  Row,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/UserResponse/styled.ts

import Timestamp from '@/components/Timestamp';
import Tooltip from '@/components/Tooltip';
import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import { styled } from '@/styles';

import Message from '../Message';

const tag = tagFactory(ClassName.USER_RESPONSE);

export const Debug = styled(tag('aside', 'debug'), {
  typo: { size: '12px', height: '17px' },
  color: '$darkGrey',
  marginTop: '$2',
});

export const Container = styled(tag('div'), {
  display: 'flex',
  flexDirection: 'column',
  flexShrink: 0,
  alignItems: 'flex-end',

  [`& > ${Tooltip.Container}`]: {
    marginTop: '$1',
  },
  variants: {
    mode: {
      overlay: {
        [`& ${Message.Container}`]: {
          maxWidth: '248px',
        },
      },
      embedded: {
        [`& ${Message.Container}`]: {
          maxWidth: '80%',
        },
      },
    },
  },

  defaultVariants: {
    mode: 'overlay',
  },
});

export const Row = styled(tag('div', 'row'), {
  display: 'flex',
  width: '100%',
  alignItems: 'center',

  [`& ${Timestamp.Container}`]: {
    flexGrow: 1,
    marginRight: 8,
    textAlign: 'end',
    opacity: '0%',
    trans: ['opacity'],
  },

  [`&:hover ${Timestamp.Container}`]: {
    opacity: '100%',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/components/index.ts

export { default as AssistantInfo } from './AssistantInfo';
export { default as Avatar } from './Avatar';
export { default as Bubble } from './Bubble';
export { default as Button } from './Button';
export { default as Card } from './Card';
export { default as Carousel } from './Carousel';
export { default as Chat } from './Chat';
export { default as ChatInput } from './ChatInput';
export { default as Footer } from './Footer';
export { default as Header } from './Header';
export { default as Icon } from './Icon';
export { default as Image } from './Image';
export { default as Input } from './Input';
export { default as Launcher } from './Launcher';
export { default as Loader } from './Loader';
export { default as Message } from './Message';
export * as Proactive from './Proactive';
export { default as Prompt } from './Prompt';
export { default as SystemResponse } from './SystemResponse';
export { Markdown, default as Text } from './Text';
export { default as Textarea } from './Textarea';
export { default as Timestamp } from './Timestamp';
export { default as Tooltip } from './Tooltip';
export { default as TypingIndicator } from './TypingIndicator';
export { default as UserResponse } from './UserResponse';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/constants.ts

import Bowser from 'bowser';

export enum ClassName {
  ASSISTANT_INFO = 'vfrc-assistant-info',
  AVATAR = 'vfrc-avatar',
  BUBBLE = 'vfrc-bubble',
  BUTTON = 'vfrc-button',
  CARD = 'vfrc-card',
  CAROUSEL = 'vfrc-carousel',
  CHAT = 'vfrc-chat',
  CHAT_INPUT = 'vfrc-chat-input',
  FEEDBACK = 'vfrc-feedback',
  FOOTER = 'vfrc-footer',
  HEADER = 'vfrc-header',
  ICON = 'vfrc-icon',
  IMAGE = 'vfrc-image',
  INPUT = 'vfrc-input',
  LAUNCHER = 'vfrc-launcher',
  LOADER = 'vfrc-loader',
  MESSAGE = 'vfrc-message',
  PROMPT = 'vfrc-prompt',
  SYSTEM_RESPONSE = 'vfrc-system-response',
  TIMESTAMP = 'vfrc-timestamp',
  TOOLTIP = 'vfrc-tooltip',
  TYPING_INDICATOR = 'vfrc-typing-indicator',
  USER_RESPONSE = 'vfrc-user-response',
  WIDGET = 'vfrc-widget',

  PROACTIVE_CLOSE = 'vfrc-proactive-close',
  PROACTIVE_MESSAGE = 'vfrc-proactive-message',
  PROACTIVE = 'vfrc-proactive',
}

export const DEVICE_INFO = Bowser.parse(window.navigator.userAgent);


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/AutoScrollContext.tsx

import React, { createContext, useCallback, useMemo } from 'react';

export interface AutoScrollContext {
  scrollToBottom: () => void;
}

export const AutoScrollContext = createContext<AutoScrollContext>({
  scrollToBottom: () => undefined,
});

export const { Consumer: AutoScrollConsumer } = AutoScrollContext;

export interface AutoScrollProviderProps<T> extends React.PropsWithChildren {
  target: React.RefObject<T>;
}

export const AutoScrollProvider = <T extends HTMLElement>({ target, children }: AutoScrollProviderProps<T>) => {
  const scrollToBottom = useCallback(() => {
    requestAnimationFrame(() => {
      const el = target.current;
      if (!el) return;

      const { scrollTop, scrollHeight, clientHeight } = el;
      const hiddenHeight = scrollHeight - clientHeight;
      if (hiddenHeight === scrollTop) return;

      el.scrollTo({ top: hiddenHeight });
    });
  }, []);

  const context = useMemo(() => ({ scrollToBottom }), [scrollToBottom]);

  return <AutoScrollContext.Provider value={context}>{children}</AutoScrollContext.Provider>;
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/audio-controller.ts

export class AudioController {
  public audio = new Audio();

  private reject: (() => void) | null = null;

  public pause(): void {
    this.audio.pause();
  }

  public continue(): void {
    this.audio.play();
  }

  public async play(src: undefined | null | string): Promise<void> {
    this.stop();

    if (!src) return Promise.resolve();

    return new Promise<void>((resolve, reject) => {
      this.reject = reject;

      this.audio.onended = () => resolve();
      this.audio.onerror = () => reject();

      this.audio.src = src;
      this.audio.currentTime = 0;

      this.audio.play();
    });
  }

  public stop(): void {
    this.reject?.();
    this.audio.pause();

    this.audio.onended = null;
    this.audio.onerror = null;
    this.audio.currentTime = 0;
  }
}


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/index.tsx

import React, { createContext, useMemo } from 'react';

import type { RuntimeState, Settings } from './useRuntimeState';
import { useRuntimeState } from './useRuntimeState';

// split up API and state to prevent unnecessary re-renders
export const RuntimeStateAPIContext = createContext<RuntimeState['api']>({} as any);
export const RuntimeStateContext = createContext<RuntimeState['state']>({} as any);

interface RuntimeProviderProps extends React.PropsWithChildren, Settings {
  extend?: (runtime: RuntimeState['api']) => RuntimeState['api'];
}

export const RuntimeProvider = ({ children, extend, ...settings }: RuntimeProviderProps) => {
  const store = useRuntimeState(settings);

  // api is a static object, so we can use useMemo to prevent unnecessary re-renders
  const api = useMemo(() => extend?.(store.api) ?? store.api, []);

  return (
    <RuntimeStateAPIContext.Provider value={api}>
      <RuntimeStateContext.Provider value={store.state}>{children}</RuntimeStateContext.Provider>
    </RuntimeStateAPIContext.Provider>
  );
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/messages.ts

import { CardTraceDTO, CarouselTraceDTO, ChoiceTraceDTO, TextTraceDTO, VisualTraceDTO } from '@voiceflow/dtos-interact';
import type { RuntimeAction, TraceDeclaration } from '@voiceflow/sdk-runtime';
import {
  CardV2TraceComponent,
  ChoiceTraceComponent,
  TextTraceComponent,
  Trace,
  VisualTraceComponent,
} from '@voiceflow/sdk-runtime';

import type { CardProps } from '@/components/Card/types';
import type { SystemResponseProps } from '@/components/SystemResponse';
import { MessageType } from '@/components/SystemResponse/constants';

export interface RuntimeMessage extends Pick<SystemResponseProps, 'messages' | 'actions'> {}

const isValidCard = (card: CardProps) => {
  return !!card.title || !!card.description || !!card.image || !!card.actions?.filter(({ name }) => !!name).length;
};

export const MESSAGE_TRACES: TraceDeclaration<RuntimeMessage, any>[] = [
  TextTraceComponent(({ context }, trace) => {
    if (!TextTraceDTO.safeParse(trace).success) return context;

    const { slate, message, ai, delay, audio } = trace.payload;

    context.messages.push({
      type: MessageType.TEXT,
      text: slate?.content || message,
      delay,
      ...(ai ? { ai } : {}),
      ...(audio ? { audio } : {}),
    });

    return context;
  }),
  VisualTraceComponent(({ context }, trace) => {
    if (!VisualTraceDTO.safeParse(trace).success) return context;

    context.messages.push({ type: MessageType.IMAGE, url: trace.payload.image });
    return context;
  }),
  ChoiceTraceComponent(({ context }, trace) => {
    if (!ChoiceTraceDTO.safeParse(trace).success) return context;

    const {
      payload: { buttons },
    } = trace;
    context.actions = (buttons as { name: string; request: RuntimeAction }[]).map(({ name, request }) => ({
      name,
      request,
    }));
    return context;
  }),
  CardV2TraceComponent(({ context }, trace) => {
    if (!CardTraceDTO.safeParse(trace).success) return context;

    const {
      payload: { title, imageUrl, description, buttons },
    } = trace;
    const card: CardProps = {
      title,
      description: description.text,
      image: imageUrl,
      actions: buttons.map(({ name, request }) => ({ name, request })),
    };

    if (isValidCard(card)) {
      context.messages.push({
        type: 'card',
        ...card,
      });
    }
    return context;
  }),
  {
    canHandle: ({ type }) => type === Trace.TraceType.CAROUSEL,
    handle: ({ context }, trace: Trace.Carousel) => {
      if (!CarouselTraceDTO.safeParse(trace).success) return context;

      const cards: CardProps[] = trace.payload.cards
        .map(({ title, description, imageUrl, buttons }) => ({
          title,
          description: description.text,
          image: imageUrl,
          actions: buttons.map(({ name, request }) => ({ name, request })),
        }))
        .filter(isValidCard);

      if (cards.length) {
        context.messages.push({
          type: MessageType.CAROUSEL,
          cards,
        });
      }

      return context;
    },
  },
  {
    canHandle: ({ type }) => type === Trace.TraceType.END,
    handle: ({ context }) => {
      context.messages.push({ type: MessageType.END });
      return context;
    },
  },
];


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/runtime.utils.test.ts

import { describe, expect, it } from 'vitest';

import { TurnType } from '@/types';

import { getLastSystemTurn, resolveAction } from './runtime.utils';

describe('getLastSystemTurn', () => {
  it('should return the last SYSTEM turn', () => {
    const mockTurns1 = [{ type: TurnType.USER }, { type: TurnType.SYSTEM }] as any[];
    expect(getLastSystemTurn(mockTurns1)).toBe(mockTurns1[1]);

    const mockTurns2 = [{ type: TurnType.SYSTEM }, { type: TurnType.USER }] as any[];
    expect(getLastSystemTurn(mockTurns2)).toBe(mockTurns2[0]);
  });

  it('should return null if no SYSTEM turn is present', () => {
    expect(getLastSystemTurn([])).toBeNull();
    expect(getLastSystemTurn([{ type: TurnType.USER }] as any)).toBeNull();
  });
});

describe('resolveAction', () => {
  it('should return the matched action if user text request matches system action name', () => {
    const mockTurns = [
      // wrong system turn:
      { type: TurnType.SYSTEM, actions: [{ name: 'action1', request: 'request0' }] },
      // right system turn:
      { type: TurnType.SYSTEM, actions: [{ name: 'action1', request: 'request1' }] },
      { type: TurnType.USER, actions: [] },
    ] as any[];

    const result = resolveAction({ type: 'text', payload: 'action1' }, mockTurns);
    expect(result).toEqual('request1');
  });

  it('should return the original action if no matching system action is found', () => {
    const mockTurns = [
      { type: TurnType.USER, actions: [] },
      { type: TurnType.SYSTEM, actions: [{ name: 'action1', request: 'request1' }] },
    ] as any[];

    const action = { type: 'text', payload: 'non-existent' };
    const result = resolveAction(action, mockTurns);
    expect(result).toEqual(action);
  });

  it('should return the original action if action is not a text request', () => {
    const mockTurns = [{ type: TurnType.SYSTEM, actions: [{ name: 'action1', request: 'request1' }] }] as any[];

    const action = { type: 'not-text', payload: 'action1' };
    const result = resolveAction(action, mockTurns);
    expect(result).toEqual(action);
  });
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/runtime.utils.ts

import { type BaseRequest, isTextRequest } from '@voiceflow/dtos-interact';

import type { SystemTurnProps, TurnProps } from '@/types';
import { TurnType } from '@/types';

export const getLastSystemTurn = (turns: TurnProps[]): SystemTurnProps | null => {
  for (let i = turns.length - 1; i >= 0; i--) {
    const turn = turns[i];
    if (turn.type === TurnType.SYSTEM) return turn;
  }

  return null;
};

const stringFuzzyEquals = (a: string, b: string) => a.trim().toLowerCase() === b.trim().toLowerCase();

// resolve the action that the user should take, based on pass turns as input
export const resolveAction = (action: BaseRequest, turns: TurnProps[]): BaseRequest => {
  if (isTextRequest(action)) {
    /// if the system has suggested actions, match action name against the user text request
    const systemTurn = getLastSystemTurn(turns);
    const matchedAction = systemTurn?.actions?.find((a) => stringFuzzyEquals(a.name, action.payload))?.request;
    if (matchedAction) return matchedAction;
  }

  return action;
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/silent-audio.ts

export const silentAudio =
  'data:audio/mpeg;base64,SUQzBAAAAAACPFRYWFgAAAAXAAADVFNTAEdhcmFnZUJhbmQgMTAuMy4zAFRYWFgAAABlAAADaVR1bk5PUk0AIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwAFRYWFgAAAB/AAADaVR1blNNUEIAIDAwMDAwMDAwIDAwMDAwMjEwIDAwMDAwODU4IDAwMDAwMDAwMDAwNDA5OTggMDAwMDAwMDAgMDAwMEI2REMgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAAVFNTRQAAAA8AAANMYXZmNTguMjkuMTAwAAAAAAAAAAAAAAD/+5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJbmZvAAAADwAAACgAAELvAAwMEhIYGBgfHyUlJSsrMTExODg+Pj5EREpKSlFRV1dXXV1jY2NqanBwcHZ2fHx8g4OJiYmPj5WVlZycoqKiqKiurq61tbu7u8HBx8fHzs7U1NTa2uDg4Ofn7e3t8/P5+fn//wAAAABMYXZjNTguNTQAAAAAAAAAAAAAAAAkBXwAAAAAAABC78H9CuUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+5BkAA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5BkQQ/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/traces/EffectExtensions.trace.ts

import type { Trace } from '@voiceflow/base-types';
import type { TraceDeclaration } from '@voiceflow/sdk-runtime';

import type { AnyExtension, EffectExtension } from '@/dtos/Extension.dto';
import { ExtensionType } from '@/dtos/Extension.dto';

import type { RuntimeMessage } from '../messages';

export const EffectExtensions = (extensions: AnyExtension[]): TraceDeclaration<RuntimeMessage, Trace.AnyTrace>[] => {
  return extensions
    .filter((extension): extension is EffectExtension => extension.type === ExtensionType.EFFECT)
    .map((extension) => ({
      canHandle: (trace) => extension.match({ trace }),

      handle: ({ context }, trace) => {
        // NOTE: this promise is intentionally left unhandled
        // we just want to capture and raise any errors thrown
        (async () => {
          try {
            await extension.effect?.({ trace });
          } catch (e) {
            console.error(`Extension '${extension.name}' threw an error: ${e}`);
          }
        })();

        return context;
      },
    }));
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/traces/NoReply.trace.ts

import type { Trace } from '@voiceflow/base-types';
import type { TraceDeclaration } from '@voiceflow/sdk-runtime';
import { ActionType } from '@voiceflow/sdk-runtime';

import { DEFAULT_MESSAGE_DELAY } from '@/components/SystemResponse/constants';

import type { RuntimeMessage } from '../messages';

export const NoReply = (callback: (timeout: number) => void): TraceDeclaration<RuntimeMessage, any> => ({
  canHandle: ({ type }) => type === ActionType.NO_REPLY,
  handle: ({ context }, trace: Trace.NoReplyTrace) => {
    if (trace.payload?.timeout) {
      // messages take 1 second to animate in, on top of the delay
      const messageDelays = context.messages.reduce(
        (acc, message) => acc + (message.delay ?? 1000) + DEFAULT_MESSAGE_DELAY,
        0
      );
      const timeout = trace.payload.timeout * 1000 + messageDelays;

      // eslint-disable-next-line callback-return
      callback(timeout);
    }
    return context;
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/traces/ResponseExtensions.trace.ts

import type { Trace } from '@voiceflow/base-types';
import type { TraceDeclaration } from '@voiceflow/sdk-runtime';

import { MessageType } from '@/components/SystemResponse/constants';
import type { AnyExtension, ResponseExtension } from '@/dtos/Extension.dto';
import { ExtensionType } from '@/dtos/Extension.dto';

import type { RuntimeMessage } from '../messages';

export const ResponseExtensions = (extensions: AnyExtension[]): TraceDeclaration<RuntimeMessage, Trace.AnyTrace>[] => {
  return extensions
    .filter((extension): extension is ResponseExtension => extension.type === ExtensionType.RESPONSE)
    .map((extension) => ({
      canHandle: (trace) => extension.match({ trace }),

      handle: ({ context }, trace) => {
        context.messages.push({ type: MessageType.EXTENSION, payload: { trace, extension } });

        return context;
      },
    }));
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/useNoReply.ts

import { BaseRequest } from '@voiceflow/base-types';
import { useCallback, useRef } from 'react';

import { SessionStatus } from '@/types';

import type { RuntimeState } from './useRuntimeState';

export const useNoReply = (api: () => Pick<RuntimeState['api'], 'interact' | 'isStatus'>) => {
  const noReplyTimeout = useRef<NodeJS.Timeout | null>(null);

  const clearNoReplyTimeout = useCallback(() => {
    if (!noReplyTimeout.current) return;

    clearTimeout(noReplyTimeout.current);
    noReplyTimeout.current = null;
  }, []);

  const setNoReplyTimeout = useCallback((timeout: number) => {
    clearNoReplyTimeout();
    noReplyTimeout.current = setTimeout(() => {
      // Trigger no reply action
      if (!api().isStatus(SessionStatus.ACTIVE)) return;

      api().interact({ type: BaseRequest.RequestType.NO_REPLY, payload: null });
    }, timeout);
  }, []);

  return { setNoReplyTimeout, clearNoReplyTimeout };
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/useRuntimeAPI.ts

import type { RuntimeAction } from '@voiceflow/sdk-runtime';
import { VoiceflowRuntime } from '@voiceflow/sdk-runtime';
import { serializeToText } from '@voiceflow/slate-serializer/text';
import { useMemo } from 'react';

import type { MessageProps } from '@/components/SystemResponse';
import { MessageType } from '@/components/SystemResponse/constants';
import { DEVICE_INFO } from '@/constants';
import type { ChatConfig } from '@/dtos/ChatConfig.dto';
import type { SessionOptions, UserTurnProps } from '@/types';

import type { RuntimeMessage } from './messages';
import { MESSAGE_TRACES } from './messages';

export enum FeedbackName {
  POSITIVE = 'Thumbs up',
  NEGATIVE = 'Thumbs down',
}

export const createContext = (): RuntimeMessage => ({
  messages: [],
});

export const useRuntimeAPI = ({
  url,
  user,
  userID,
  verify,
  versionID,
  traceHandlers = [],
}: ChatConfig & Pick<SessionOptions, 'userID'> & { traceHandlers?: typeof MESSAGE_TRACES }) => {
  const runtime: VoiceflowRuntime<RuntimeMessage> = useMemo(
    () =>
      new VoiceflowRuntime<RuntimeMessage>({
        verify,
        url,
        traces: [...MESSAGE_TRACES, ...traceHandlers],
      }),
    []
  );

  const interact = async (action: RuntimeAction, config?: any) =>
    runtime.interact(createContext(), {
      sessionID: userID,
      action,
      config,
      ...(versionID && { versionID }),
    });

  const saveFeedback = async (name: FeedbackName, lastTurnMessages: MessageProps[], userTurn: UserTurnProps | null) => {
    const aiMessages: string[] = [];

    lastTurnMessages.forEach((message) => {
      if (!message.ai) return;
      if (message.type !== MessageType.TEXT) return;
      const text = typeof message.text === 'string' ? message.text : serializeToText(message.text);

      aiMessages.push(text);
    });

    await runtime.feedback({
      sessionID: userID,
      name,
      text: aiMessages,
      lastUserTurn: userTurn,
      ...(versionID && { versionID }),
    });
  };

  const saveTranscript = async () => {
    const {
      browser: { name: browser },
      os: { name: os },
      platform: { type: device },
    } = DEVICE_INFO;

    await runtime.createTranscript(userID, {
      ...(os && { os }),
      ...(browser && { browser }),
      ...(device && { device }),
      ...(user && { user: user as { name: string } }),
    });
  };

  return { interact, saveFeedback, saveTranscript };
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/RuntimeContext/useRuntimeState.ts

import type { BaseRequest } from '@voiceflow/dtos-interact';
import { isTextRequest, RequestType } from '@voiceflow/dtos-interact';
import type { TraceDeclaration } from '@voiceflow/sdk-runtime';
import cuid from 'cuid';
import { useEffect, useRef, useState } from 'react';

import { DEFAULT_MESSAGE_DELAY, MessageType } from '@/components/SystemResponse/constants';
import { isIOS } from '@/device';
import type { AssistantOptions } from '@/dtos/AssistantOptions.dto';
import type { ChatConfig } from '@/dtos/ChatConfig.dto';
import { useStateRef } from '@/hooks/useStateRef';
import { useLocalStorageState } from '@/hooks/useStorage';
import type { SendMessage, SessionOptions, TurnProps } from '@/types';
import { SessionStatus, TurnType } from '@/types';
import { handleActions } from '@/utils/actions';
import { broadcast, BroadcastType } from '@/utils/broadcast';
import { getSession, saveSession } from '@/utils/session';

import { AudioController } from './audio-controller';
import type { RuntimeMessage } from './messages';
import { resolveAction } from './runtime.utils';
import { silentAudio } from './silent-audio';
import { EffectExtensions } from './traces/EffectExtensions.trace';
import { NoReply } from './traces/NoReply.trace';
import { ResponseExtensions } from './traces/ResponseExtensions.trace';
import { useNoReply } from './useNoReply';
import { createContext, useRuntimeAPI } from './useRuntimeAPI';

export interface Settings {
  assistant: AssistantOptions;
  config: ChatConfig;
  traceHandlers?: TraceDeclaration<RuntimeMessage, any>[];
}

const DEFAULT_SESSION_PARAMS = {
  turns: [],
  startTime: Date.now(),
};

export const useRuntimeState = ({ assistant, config, traceHandlers }: Settings) => {
  const [audio] = useState(() => new AudioController());
  const playAudiosStack = useRef<string[]>([]);
  const [isOpen, setOpen] = useState(false);
  const [audioOutput, setAudioOutput, audioOutputRef] = useLocalStorageState(
    'audio-output',
    assistant.defaultAudioOutput ?? false
  );

  const [session, setSession, sessionRef] = useStateRef<Required<SessionOptions>>(() => ({
    ...DEFAULT_SESSION_PARAMS,
    status: config.autostart ? SessionStatus.IDLE : SessionStatus.ENDED,
    // retrieve stored session
    ...getSession(assistant.persistence, config.verify.projectID, config.userID),
  }));

  const [indicator, setIndicator] = useState(false);
  const { clearNoReplyTimeout, setNoReplyTimeout } = useNoReply(() => ({ interact, isStatus }));

  const runtime = useRuntimeAPI({
    ...config,
    ...session,
    traceHandlers: [
      NoReply(setNoReplyTimeout),
      ...EffectExtensions(assistant.extensions),
      ...ResponseExtensions(assistant.extensions),
      ...(traceHandlers ?? []),
    ],
  });

  const isAudioOutputEnabled = () => assistant.audioInterface && audioOutputRef.current;

  // status management
  const setStatus = (status: SessionStatus) => {
    setSession((prev) => (prev.status === status ? prev : { ...prev, status }));
  };
  const isStatus = (status: SessionStatus) => {
    return sessionRef.current.status === status;
  };

  // turn management
  const setTurns = (action: (turns: TurnProps[]) => TurnProps[]) => {
    setSession((prev) => ({ ...prev, turns: action(prev.turns) }));
  };

  const addTurn = (turn: TurnProps) => setTurns((prev) => [...prev, turn]);

  const reset = () => setTurns(() => []);

  const interact: SendMessage = async (action: BaseRequest, message?: string) => {
    clearNoReplyTimeout();

    if (sessionRef.current.status === SessionStatus.ENDED) return;

    // create a transcript on the first turn, do this async
    if (sessionRef.current.turns.length === 1) runtime.saveTranscript();

    handleActions(action);

    const userMessage = message || (isTextRequest(action) ? action.payload : null);
    if (userMessage) {
      addTurn({
        id: cuid(),
        type: TurnType.USER,
        message: userMessage,
        timestamp: Date.now(),
      });
    }

    const userAction = resolveAction(action, getTurns());

    setIndicator(true);
    const context = await runtime.interact(userAction, { tts: isAudioOutputEnabled() }).catch((error) => {
      // TODO: better define error condition
      console.error(error);
      return createContext();
    });
    setIndicator(false);

    addTurn({
      id: cuid(),
      type: TurnType.SYSTEM,
      timestamp: Date.now(),
      ...context,
    });

    const shouldPlay = isAudioOutputEnabled() && playAudiosStack.current.length === 0;

    if (isAudioOutputEnabled()) {
      context.messages.forEach((message) => {
        if (message.type === MessageType.TEXT && message.audio?.src) {
          playAudiosStack.current.push(message.audio.src);
        }
      });
    }

    if (shouldPlay) {
      // eslint-disable-next-line no-promise-executor-return
      await new Promise((resolve) => setTimeout(resolve, DEFAULT_MESSAGE_DELAY));

      playAudioCircle();
    }

    broadcast({ type: BroadcastType.INTERACT, payload: { session: sessionRef.current, action: userAction } });
    saveSession(assistant.persistence, config.verify.projectID, sessionRef.current);
  };

  const launch = async (): Promise<void> => {
    playAudiosStack.current = [];

    // we need to play a silent audio on user interaction to enable async audio playback
    if (isIOS() && isAudioOutputEnabled()) {
      audio.play(silentAudio);
    }

    if (sessionRef.current.turns.length) reset();

    setStatus(SessionStatus.ACTIVE);
    await interact(config.launch?.event ?? { type: RequestType.LAUNCH });
  };

  const reply = async (message: string): Promise<void> => {
    stopAudios();

    interact({ type: RequestType.TEXT, payload: message });
  };

  const open = async () => {
    broadcast({ type: BroadcastType.OPEN });
    setOpen(true);

    if (isStatus(SessionStatus.IDLE)) {
      await launch();
    }
  };

  const close = () => {
    stopAudios();

    broadcast({ type: BroadcastType.CLOSE });
    saveSession(assistant.persistence, config.verify.projectID, sessionRef.current);
    setOpen(false);
  };

  const getTurns = () => sessionRef.current.turns;

  const stopAudios = () => {
    playAudiosStack.current = [];
    audio.stop();
  };

  const playAudioCircle = async () => {
    if (!isAudioOutputEnabled() || !playAudiosStack.current.length) return;

    await audio.play(playAudiosStack.current.shift());

    playAudioCircle();
  };

  const toggleAudioOutput = () => {
    stopAudios();
    setAudioOutput((prev) => !prev);
  };

  useEffect(() => {
    if (!isOpen) return undefined;

    return () => {
      stopAudios();
    };
  }, [isOpen]);

  return {
    state: {
      session,
      isOpen,
      indicator,
      audioOutput,
    },
    api: {
      launch,
      reply,
      open,
      interact,
      close,
      addTurn,
      feedback: runtime.saveFeedback,
      setStatus,
      setOpen,
      isStatus,
      reset,
      getTurns,
      setIndicator,
      setAudioOutput,
      toggleAudioOutput,

      // these are meant to be static, so bundling them with the API
      assistant,
      config,
    },
  };
};

export type RuntimeState = ReturnType<typeof useRuntimeState>;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/contexts/index.ts

export * from './AutoScrollContext';
export * from './RuntimeContext';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/device.ts

import { DEVICE_INFO } from '@/constants';

export const isIOS = () => DEVICE_INFO.os.name === 'iOS';

export const isBrave = () => {
  const browserNavigator = globalThis.navigator as Navigator & { brave?: { isBrave: () => boolean } };

  if (!browserNavigator) return false;

  if (browserNavigator.brave !== undefined) {
    return browserNavigator.brave.isBrave.name === 'isBrave';
  }

  return false;
};

export const isArc = () => !!getComputedStyle(document.documentElement).getPropertyValue('--arc-palette-title');
export const isEdge = () => DEVICE_INFO.browser.name === 'Microsoft Edge';
export const isOpera = () => DEVICE_INFO.browser.name === 'Opera';
export const isChrome = () => !isBrave() && !isArc() && DEVICE_INFO.browser.name === 'Chrome';
export const isSafari = () => DEVICE_INFO.browser.name === 'Safari';
export const isFirefox = () => DEVICE_INFO.browser.name === 'Firefox';
export const isChromium = () => isEdge() || isChrome() || isBrave() || isArc() || isOpera();


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/dtos/AssistantOptions.dto.ts

import { z } from 'zod';

import { PRIMARY } from '@/styles/color';
import { ChatPersistence, ChatPosition } from '@/types';

import { AnyExtension } from './Extension.dto';

export const DEFAULT_AVATAR = 'https://cdn.voiceflow.com/assets/logo.png';

export type AssistantOptions = z.infer<typeof AssistantOptions>;
export type RawAssistantOptions = z.input<typeof AssistantOptions>;

export const AssistantOptions = z
  .object({
    title: z.string().default('Voiceflow Assistant'),
    color: z.string().default(PRIMARY),
    image: z.string().default(DEFAULT_AVATAR),
    avatar: z.string().default(DEFAULT_AVATAR),
    launcher: z.string().optional(),
    watermark: z.boolean().default(true),
    feedback: z.boolean().default(false),
    stylesheet: z.union([z.string(), z.string().array()]).optional(),
    description: z.string().default(''),
    position: z.nativeEnum(ChatPosition).default(ChatPosition.RIGHT),
    persistence: z.nativeEnum(ChatPersistence).default(ChatPersistence.LOCAL_STORAGE),
    audioInterface: z.boolean().default(false),
    defaultAudioOutput: z.boolean().optional(),

    spacing: z
      .object({
        side: z.number().default(30),
        bottom: z.number().default(30),
      })
      .default({}),

    extensions: AnyExtension.array().default([]),
  })
  .default({});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/dtos/ChatConfig.dto.test.ts

import { describe, expect, it } from 'vitest';

import { ChatConfig, RUNTIME_URL } from './ChatConfig.dto';
import { RenderMode } from './RenderOptions.dto';

describe('ChatConfig', () => {
  describe('parse()', () => {
    it('should accept a minimal configuration', () => {
      const projectID = 'projectID';

      const result = ChatConfig.parse({
        verify: { projectID },
      });

      expect(result).toEqual({
        autostart: true,
        allowDangerousHTML: true,
        url: RUNTIME_URL,
        verify: { projectID },
        render: { mode: RenderMode.OVERLAY },
      });
    });

    it('should accept all configuration options', () => {
      const localOptions = {
        autostart: true,
        allowDangerousHTML: false,

        url: 'local',
        userID: 'local',
        versionID: 'local',

        verify: { projectID: 'local' },
        user: { name: 'local', image: 'local' },
        render: { mode: RenderMode.OVERLAY },
        launch: { event: { type: 'local' } },
      };

      const result = ChatConfig.parse(localOptions);

      expect(result).toEqual(localOptions);
    });

    it('should accept a numeric userID', () => {
      const projectID = 'projectID';

      const result = ChatConfig.parse({
        verify: { projectID },
        userID: 123,
      });

      expect(result).toEqual({
        autostart: true,
        allowDangerousHTML: true,
        url: RUNTIME_URL,
        verify: { projectID },
        render: { mode: RenderMode.OVERLAY },
        userID: '123',
      });
    });

    it('should accept and decode a string userID', () => {
      const projectID = 'projectID';

      const result = ChatConfig.parse({
        verify: { projectID },
        userID: 'foo%20bar',
      });

      expect(result).toEqual({
        autostart: true,
        allowDangerousHTML: true,
        url: RUNTIME_URL,
        verify: { projectID },
        render: { mode: RenderMode.OVERLAY },
        userID: 'foo bar',
      });
    });
  });
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/dtos/ChatConfig.dto.ts

import type { BaseRequest } from '@voiceflow/dtos-interact';
import type { PrototypeVerify, PublicVerify, RuntimeOptions as SDKRuntimeOptions } from '@voiceflow/sdk-runtime';
import { z } from 'zod';

import type { RawAssistantOptions } from './AssistantOptions.dto';
import { RenderMode, RenderOptions } from './RenderOptions.dto';

export const RUNTIME_URL = 'https://general-runtime.voiceflow.com';

const tryDecodeURIComponent = (str: string) => {
  try {
    return decodeURIComponent(str);
  } catch {
    return str;
  }
};

export type VerifyOptions = z.infer<typeof VerifyOptions>;
export type UserOptions = z.infer<typeof UserOptions>;
export type LaunchOptions = z.infer<typeof LaunchOptions>;

export const VerifyOptions = z.union([
  z.object({ projectID: z.string() }),
  z.object({ projectID: z.string(), versionID: z.string(), prototype: z.literal(true) }),
]);

export const LaunchOptions = z
  .object({
    event: z
      .object({ type: z.string() })
      .passthrough()
      .transform((x) => x as unknown as BaseRequest),
  })
  .partial();

export const UserOptions = z
  .object({
    name: z.string(),
    image: z.string(),
  })
  .partial();

type Config<T extends SDKRuntimeOptions<PublicVerify | PrototypeVerify>> = T;

export interface ChatConfig extends Config<z.infer<typeof ChatConfig>> {}

export interface LoadConfig extends Omit<ChatConfig, 'url'> {
  url?: ChatConfig['url'];
  assistant?: RawAssistantOptions;
}

export const ChatSpeechRecognitionState = z.object({
  listening: z.boolean(),
  transcript: z.string(),
  processing: z.boolean(),
  initializing: z.boolean(),
  microphoneAvailable: z.boolean().describe('If false, the user has not given permission for their microphone.'),
});

export type ChatSpeechRecognitionState = z.infer<typeof ChatSpeechRecognitionState>;

export const ChatSpeechRecognitionConfig = z.object({
  overrideNative: z
    .boolean()
    .optional()
    .default(false)
    .describe(
      'If true, uses the custom speech recognition implementation even if the native (browsers) one is available.'
    ),
  initialState: ChatSpeechRecognitionState,
  onStateChange: z
    .function()
    .args(z.function().args(ChatSpeechRecognitionState).returns(z.void()))
    .returns(z.function().returns(z.void())),
  stopListening: z.function().returns(z.void()),
  startListening: z
    .function()
    .returns(z.void())
    .describe(
      `Starts listening for speech input.
      User has to give permission for their microphone to be used before listening can begin.
      If the user has not given permission, needs to update microphoneAvailable: false state.`
    ),
  resetTranscript: z.function().returns(z.void()),
});

export type ChatSpeechRecognitionConfig = z.infer<typeof ChatSpeechRecognitionConfig>;

export const ChatConfig = z
  .object({
    autostart: z.boolean().optional(),
    // default to true during migration period, turn off later
    allowDangerousHTML: z.boolean().default(true),

    url: z.string().default(RUNTIME_URL),
    userID: z
      .union([z.number(), z.string()])
      .transform((x) => {
        if (typeof x === 'number') return String(x);
        return tryDecodeURIComponent(x);
      })
      .optional(),
    versionID: z.string().optional(),

    verify: VerifyOptions,
    user: UserOptions.optional(),
    render: RenderOptions,
    launch: LaunchOptions.optional(),
    speechRecognition: ChatSpeechRecognitionConfig.optional(),
  })
  .transform((config) => ({
    ...config,

    // if not configured default to enabling autostart during overlay mode and disabling it otherwise
    autostart: config.autostart ?? config.render.mode === RenderMode.OVERLAY,
  }));


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/dtos/Extension.dto.ts

import type { Trace } from '@voiceflow/base-types';
import { z } from 'zod';

export enum ExtensionType {
  EFFECT = 'effect',
  RESPONSE = 'response',
}

export type EffectExtension = z.infer<typeof EffectExtension>;
export type ResponseExtension = z.infer<typeof ResponseExtension>;
export type AnyExtension = z.infer<typeof AnyExtension>;

const Extension = <Type extends ExtensionType>(type: Type) =>
  z.object({
    name: z.string(),
    type: z.literal(type),
    match: z.function().transform((f) => f as (context: { trace: Trace.AnyTrace }) => boolean),
  });

export const EffectExtension = Extension(ExtensionType.EFFECT).extend({
  effect: z
    .function()
    .transform((f) => f as (context: { trace: Trace.AnyTrace }) => Promise<void> | void)
    .optional(),
});

export const ResponseExtension = Extension(ExtensionType.RESPONSE).extend({
  render: z
    .function()
    .transform((f) => f as (context: { trace: Trace.AnyTrace; element: HTMLElement }) => (() => void) | void)
    .optional(),
});

export const AnyExtension = z.discriminatedUnion('type', [EffectExtension, ResponseExtension]);


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/dtos/RenderOptions.dto.test.ts

import { describe, expect, it, vi } from 'vitest';

import { EMBEDDED_TARGET, RenderMode, RenderOptions } from './RenderOptions.dto';

describe('RenderOptions', () => {
  describe('parse()', () => {
    it('should render in overlay mode by default', () => {
      const result = RenderOptions.parse(undefined);

      expect(result).toEqual({ mode: RenderMode.OVERLAY });
    });

    it('should render in embedded mode', () => {
      const renderOptions = {
        mode: RenderMode.EMBEDDED,
        target: Object.create(HTMLElement.prototype),
      };

      const result = RenderOptions.parse(renderOptions);

      expect(result).toEqual(renderOptions);
    });

    it('should try to find a target with a known name when in embedded mode', () => {
      const target = Object.create(HTMLElement.prototype);
      const getElementById = vi.spyOn(document, 'getElementById').mockImplementation(() => target);

      const result = RenderOptions.parse({ mode: RenderMode.EMBEDDED });

      expect(result).toEqual({ mode: RenderMode.EMBEDDED, target });
      expect(getElementById).toBeCalledWith(EMBEDDED_TARGET);
    });

    it('should fallback to overlay mode when a target is not provided', () => {
      const result = RenderOptions.parse({ mode: RenderMode.EMBEDDED });

      expect(result).toEqual({ mode: RenderMode.OVERLAY });
    });
  });
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/dtos/RenderOptions.dto.ts

import { z } from 'zod';

export const EMBEDDED_TARGET = 'voiceflow-chat-frame';

export enum RenderMode {
  EMBEDDED = 'embedded',
  OVERLAY = 'overlay',
}

export type RenderOptions = z.infer<typeof RenderOptions>;

export const RenderOptions = z
  .object({
    mode: z.nativeEnum(RenderMode).default(RenderMode.OVERLAY),
    target: z
      .instanceof(HTMLElement)
      .optional()
      .transform((x) => x ?? document.getElementById(EMBEDDED_TARGET) ?? undefined),
  })
  .optional()
  .transform((render) => {
    if (render?.target && render.mode !== RenderMode.EMBEDDED) {
      console.warn(`render.target has no effect in ${render.mode} mode.`);
    }

    if (render?.mode === RenderMode.EMBEDDED) {
      if (render.target) {
        return {
          mode: RenderMode.EMBEDDED as const,
          target: render.target,
        };
      }

      console.error('No valid target found for embedded mode. Defaulting to overlay mode.');
    }

    return { mode: RenderMode.OVERLAY as const };
  });


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/fixtures.ts

export const VF_ICON = 'https://cm4-production-assets.s3.amazonaws.com/1668625026913-vf-icon.png';

export const MOCK_IMAGE = 'https://picsum.photos/seed/9/300/200';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hocs/index.ts

export * from './tag';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hocs/tag.tsx

import clsx from 'clsx';
import { createElement, forwardRef } from 'react';

export const tagFactory =
  (
    prefix: string
  ): {
    <Tag extends keyof JSX.IntrinsicElements>(
      tag: Tag,
      suffix?: string
    ): (props: React.ComponentProps<Tag>) => React.ReactElement;
    <Props>(component: React.ComponentType<Props>, suffix?: string): (props: Props) => React.ReactElement;
  } =>
  (tagOrComponent: keyof JSX.IntrinsicElements | React.ComponentType<any>, suffix?: string) => {
    return forwardRef((props: any, ref) =>
      createElement(tagOrComponent, {
        ...props,
        ref,
        className: clsx(suffix ? `${prefix}--${suffix}` : prefix, props.className),
      })
    ) as any;
  };


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hooks/index.ts

export * from './useAutoScroll';
export * from './useChatAPI';
export * from './useDidUpdateEffect';
export * from './useStateRef';
export * from './useTheme';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hooks/useAutoScroll.ts

import { useContext, useLayoutEffect } from 'react';

import { AutoScrollContext } from '@/contexts';

export const useAutoScroll = (dependencies: any[] = []): void => {
  const { scrollToBottom } = useContext(AutoScrollContext);

  useLayoutEffect(() => {
    scrollToBottom();
  }, dependencies);
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hooks/useChatAPI.ts

import { useEffect } from 'react';
import { isObject } from 'remeda';
import type { PartialDeep } from 'type-fest';

import { createPlaceholderMethods } from '@/utils/chat';

export const useChatAPI = (
  target: Record<string, any> | undefined,
  factory: () => PartialDeep<VoiceflowChat>,
  onReady?: () => void
) =>
  useEffect(() => {
    if (!isObject(target)) return undefined;

    const placeholders = createPlaceholderMethods((method) => `Method '${method}' has no effect in this mode.`);
    const methods = factory();

    Object.assign(target, {
      ...placeholders,
      ...methods,
      proactive: {
        ...placeholders.proactive,
        ...methods.proactive,
      },
    });

    onReady?.();

    return () => {
      const methods = createPlaceholderMethods(
        (method) =>
          `Method '${method}' has no effect after 'destroy' has been called. Call 'load' to render the chat and restore this method.`
      );

      Object.assign(target, methods);
    };
  }, []);


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hooks/useDidUpdateEffect.ts

import { useEffect, useRef } from 'react';

export const useDidUpdateEffect = (callback: () => void | VoidFunction, dependencies: unknown[] = []): void => {
  const didMount = useRef(false);

  useEffect(() => {
    if (didMount.current) {
      return callback();
    }

    didMount.current = true;

    return undefined;
  }, dependencies);
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hooks/useStateRef.ts

import type { Dispatch, SetStateAction } from 'react';
import { useCallback, useRef, useState } from 'react';

const isFunction = <S>(setStateAction: SetStateAction<S>): setStateAction is (prevState: S) => S =>
  typeof setStateAction === 'function';

interface ReadOnlyRefObject<T> {
  readonly current: T;
}

interface UseStateRef {
  <S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>, ReadOnlyRefObject<S>];
  <S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>, ReadOnlyRefObject<S | undefined>];
}

export const useStateRef: UseStateRef = <S>(initialState?: S | (() => S)) => {
  const [state, setState] = useState(initialState);
  const ref = useRef(state);

  const dispatch: typeof setState = useCallback((setStateAction: any) => {
    ref.current = isFunction(setStateAction) ? setStateAction(ref.current) : setStateAction;

    setState(ref.current);
  }, []);

  return [state, dispatch, ref];
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hooks/useStorage.ts

import { useCallback, useMemo, useRef, useState } from 'react';

interface Storage {
  getItem: (key: string) => string | null;
  setItem: (key: string, value: string) => void;
  removeItem: (key: string) => void;
}

const createUseStorageHook =
  <S extends Storage>(storage: S) =>
  <T>(name: string, defaultValue: T) =>
    useMemo(() => {
      const storageName = `voiceflow-chat-widget:${name}`;

      return {
        get: (): T => {
          try {
            const item = storage.getItem(storageName);

            return item === null ? defaultValue : JSON.parse(item);
          } catch {
            return defaultValue;
          }
        },

        set: (value: T) => storage.setItem(storageName, JSON.stringify(value)),

        clear: () => storage.removeItem(storageName),
      };
    }, []);

const createUseStorageStateHook = <S extends Storage>(storage: S) => {
  const useStorage = createUseStorageHook(storage);

  return <T>(name: string, initialState: T) => {
    const storage = useStorage(name, initialState);
    const [value, setValue] = useState(storage.get);
    const ref = useRef(value);

    const setStorageValue = useCallback<React.Dispatch<React.SetStateAction<T>>>((value) => {
      setValue((prevState) => {
        let nextValue: T;

        if (typeof value === 'function') {
          nextValue = (value as (prevState: T) => T)(prevState);
        } else {
          nextValue = value;
        }

        storage.set(nextValue);
        ref.current = nextValue;

        return nextValue;
      });
    }, []);

    return [value, setStorageValue, ref] as const;
  };
};

export const useLocalStorage = createUseStorageHook(globalThis.localStorage);
export const useSessionStorage = createUseStorageHook(globalThis.localStorage);

export const useLocalStorageState = createUseStorageStateHook(globalThis.localStorage);
export const useSessionStorageState = createUseStorageStateHook(globalThis.sessionStorage);


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/hooks/useTheme.ts

import { useEffect, useState } from 'react';

import type { AssistantOptions } from '@/dtos/AssistantOptions.dto';
import { createCustomTheme } from '@/styles';

export const useTheme = (assistant?: AssistantOptions) => {
  const [theme, setTheme] = useState('');
  useEffect(() => {
    if (assistant?.color) {
      setTheme(createCustomTheme({ color: assistant.color }));
    }
  }, [assistant?.color]);

  return theme;
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/index.tsx

import 'regenerator-runtime/runtime';

import type { Root } from 'react-dom/client';
import { createRoot } from 'react-dom/client';

import { RuntimeProvider } from './contexts';
import type { LoadConfig } from './dtos/ChatConfig.dto';
import { ChatConfig } from './dtos/ChatConfig.dto';
import { RenderMode } from './dtos/RenderOptions.dto';
import { shadowRoot } from './styles/shadow';
import { stitches } from './styles/theme';
import { mergeAssistantOptions } from './utils/assistant';
import { createPlaceholderMethods } from './utils/chat';
import { ChatEmbed, ChatWidget } from './views';

let reactRoot: Root;

const initOverlayMode = () => {
  reactRoot = createRoot(shadowRoot);

  return { shadowRoot, reactRoot };
};

const initEmbeddedMode = (rootEl: HTMLElement) => {
  try {
    const shadowRoot = rootEl.attachShadow({ mode: 'open' });
    reactRoot = createRoot(shadowRoot);
    stitches.transplant(shadowRoot);

    return { shadowRoot, reactRoot };
  } catch (e) {
    console.error(`${e}. \nTarget:`, rootEl);
    throw new Error('Failed to attach embedded chat to the provided target.');
  }
};

const createChatRoot = (config: ChatConfig) => {
  if (config.render.mode === RenderMode.EMBEDDED) {
    return initEmbeddedMode(config.render.target);
  }

  return initOverlayMode();
};

const methods = createPlaceholderMethods(
  (method: string) => `Method '${method}' will have no effect until 'load' has been called.`
);

window.voiceflow ??= {};
window.voiceflow.chat ??= {
  ...methods,
  proactive: { ...methods.proactive },

  load: async (loadConfig: LoadConfig) => {
    const config = ChatConfig.parse(loadConfig);
    const assistant = await mergeAssistantOptions(config, loadConfig.assistant);

    const { reactRoot, shadowRoot } = createChatRoot(config);

    // set root here
    await new Promise<void>((resolve) => {
      reactRoot.render(
        <RuntimeProvider assistant={assistant} config={config}>
          {config.render.mode === RenderMode.EMBEDDED && (
            <ChatEmbed shadowRoot={shadowRoot} chatAPI={window.voiceflow?.chat} ready={resolve} />
          )}
          {config.render.mode === RenderMode.OVERLAY && (
            <ChatWidget shadowRoot={shadowRoot} chatAPI={window.voiceflow?.chat} ready={resolve} />
          )}
        </RuntimeProvider>
      );
    });
  },

  destroy: () => reactRoot.render(null),
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/package.entry.ts

export * from './common';
export * from './components';
export * from './contexts';
export type { RuntimeState } from './contexts/RuntimeContext/useRuntimeState';
export * from './dtos/AssistantOptions.dto';
export * from './dtos/ChatConfig.dto';
export * from './dtos/Extension.dto';
export * from './dtos/RenderOptions.dto';
export * from './hooks';
export * from './styles';
export * from './types/trace';
export * from './types/turn';
export * from './utils/functional';
export * from './views';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/styles/animation.ts

import type { CSS } from '@/styles/theme';
import { keyframes } from '@/styles/theme';

export const pulse = keyframes({
  '50%': { opacity: 1 },
});

export const fadeIn = keyframes({
  from: { opacity: 0 },
  to: { opacity: 1 },
});

export const rotate = keyframes({
  from: { transform: 'rotate(0deg)' },
  to: { transform: 'rotate(360deg)' },
});

export const shift = (distance: number) =>
  keyframes({
    from: { transform: `translateY(${distance}px)` },
    to: { transform: 'translateY(0px)' },
  });

export const animationStyles = ({
  distance = 12,
  duration,
  delay,
}: {
  distance?: number;
  duration: number;
  delay: number;
}): CSS => ({
  opacity: 0,
  animation: [fadeIn, shift(distance)]
    .map((animation) => `${animation} ${duration}ms ease-out ${delay}ms forwards`)
    .join(', '),
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/styles/color.ts

import chroma from 'chroma-js';

export const PRIMARY = '#3d82e2';
export const WARN = '#db1b42';

export const SHADOWS = {
  shadow1: 'rgba(0,0,0,0.01)',
  shadow2: 'rgba(0,0,0,0.02)',
  shadow3: 'rgba(0,0,0,0.03)',
  shadow4: 'rgba(0,0,0,0.04)',
  shadow6: 'rgba(0,0,0,0.06)',
  shadow8: 'rgba(0,0,0,0.08)',
  shadow12: 'rgba(0,0,0,0.12)',
  shadow16: 'rgba(0,0,0,0.16)',

  surfaceZ1Light:
    '0px 1px 3px 1px rgba(22, 26, 30, 0.01), 0px 4px 8px -6px rgba(22, 26, 30, 0.08), 0px 1px 5px -4px rgba(22, 26, 30, 0.08), 0px 0px 0px 1px rgba(22, 26, 30, 0.04), 0px 1px 0px 0px rgba(22, 26, 30, 0.02)',
};

export const createPrimaryColors = (primary: string) => ({
  primary,
  darkPrimary: chroma(primary).darken(0.25).hex(),
  fadedPrimary: chroma(primary).alpha(0.45).hex(),
});

export const PALETTE = {
  black: 'rgba(0,0,0,0.9)',
  white: '#fff',
  lightGrey: '#f4f4f4',
  medGrey: '#dfdfdf',
  darkGrey: '#737376',
  blue: PRIMARY,
  warn: WARN,
  darkWarn: chroma(WARN).darken(0.25).hex(),
  ...createPrimaryColors(PRIMARY),

  ...SHADOWS,
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/styles/font.ts

export const FAMILY = "'Open Sans', sans-serif";

export const SIZES = {
  1: '13px',
  2: '15px',
  3: '18px',
};

export const WEIGHTS = {
  1: 400,
  2: 600,
};

export const LINE_HEIGHTS = {
  1: '20px',
  2: '22px',
  3: '24px',
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/styles/fragments.ts

import type { CSS } from './theme';

export const textOverflowStyles: CSS = {
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  whiteSpace: 'nowrap',
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/styles/index.ts

export * from './animation';
export * from './color';
export * from './fragments';
export * from './theme';


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/styles/shadow.ts

// create shadow dom
export const VOICEFLOW_ID = 'voiceflow-chat';

const rootEl = document.createElement('div');
rootEl.id = VOICEFLOW_ID;

document.body.appendChild(rootEl);
export const shadowRoot = rootEl.attachShadow({ mode: 'open' });


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/styles/theme.ts

import type { CSS as BaseCSS } from '@voiceflow/stitches-react';
import { createStitches } from '@voiceflow/stitches-react';
import type { PropertiesHyphen as CSSPropertiesHyphen } from 'csstype';
import type { StringKeyOf } from 'type-fest';

import * as Color from './color';
import * as Font from './font';
import { shadowRoot } from './shadow';

const ANIMATION_DURATION = 150;

export const createTransition = (properties: Array<keyof CSSPropertiesHyphen>, duration = ANIMATION_DURATION) =>
  properties.map((property) => `${property} ${duration}ms ease`).join(', ');

export type CSS = BaseCSS<(typeof stitches)['config']>;

type Token<T extends Record<string, any>> = `$${StringKeyOf<T>}`;

export interface FontOptions {
  size?: BaseCSS['fontSize'] | Token<(typeof Font)['SIZES']>;
  weight?: BaseCSS['fontWeight'] | Token<(typeof Font)['WEIGHTS']>;
  height?: BaseCSS['lineHeight'] | Token<(typeof Font)['LINE_HEIGHTS']>;
}

export const getDefaultTheme = () => ({
  ...(__USE_SHADOW_ROOT__ && { root: shadowRoot }),

  theme: {
    colors: Color.PALETTE,
    shadows: Color.SHADOWS,

    space: {
      1: '4px',
      2: '6px',
      3: '12px',
      4: '16px',
      5: '20px',
      6: '24px',
    },
    sizes: {
      xxs: '16px',
      xs: '24px',
      sm: '36px',
      md: '42px',
      lg: '56px',
      xl: '60px',
      xxl: '72px',
    },

    fonts: {
      default: Font.FAMILY,
    },
    fontSizes: Font.SIZES,
    fontWeights: Font.WEIGHTS,
    lineHeights: Font.LINE_HEIGHTS,

    radii: {
      1: '8px',
      2: '10px',
      round: '50%',
    },
  },

  media: {
    mobile: '(max-width: 768px)',
  },

  utils: {
    anim: (animations: Array<() => string>) => ({
      animation: animations.map((animation) => `${animation} ${ANIMATION_DURATION}ms`).join(', '),
    }),

    trans: (properties: Array<keyof CSSPropertiesHyphen>) => ({
      transition: createTransition(properties),
    }),

    typo: ({ size = Font.SIZES[2], weight = Font.WEIGHTS[1], height = Font.LINE_HEIGHTS[1] }: FontOptions) => ({
      fontFamily: '$default',
      fontSize: size,
      fontWeight: weight,
      lineHeight: height,
    }),
  },
});

export const stitches = createStitches(getDefaultTheme(), __USE_SHADOW_ROOT__);
export const { styled, keyframes, theme, createTheme } = stitches;

interface ThemeOverrides {
  color?: string;
}
export const createCustomTheme = ({ color }: ThemeOverrides) =>
  createTheme({
    colors: color ? Color.createPrimaryColors(color) : {},
  });


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/types/index.ts

import type { $$StyledComponentProps } from '@voiceflow/stitches-react/types/styled-component';
export * from './session';
export * from './trace';
export * from './turn';
export * from './util';
export { ChatPersistence, ChatPosition } from '@voiceflow/voiceflow-types/build/cjs/version/chat';

export type Nullish<T> = T | null | undefined;

export type VariantProp<
  Component extends { [key: symbol | string]: any },
  Key extends keyof Component[$$StyledComponentProps],
> = Component[$$StyledComponentProps][Key];


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/types/session.ts

import type { BaseRequest } from '@voiceflow/dtos-interact';
import type { RuntimeAction } from '@voiceflow/sdk-runtime';
import { ChatPersistence, ChatPosition } from '@voiceflow/voiceflow-types/build/cjs/version/chat';

import type { TurnProps } from './turn';

export { ChatPersistence, ChatPosition };
export type { RuntimeAction };

export type SendMessage = (action: BaseRequest, message?: string) => Promise<void>;

export enum SessionStatus {
  IDLE = 'IDLE',
  ACTIVE = 'ACTIVE',
  ENDED = 'ENDED',
}

export interface SessionOptions {
  userID: string;
  turns?: TurnProps[];
  startTime?: number;
  status?: SessionStatus;
}


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/types/trace.ts

import type { Trace } from '@voiceflow/base-types';
import type { TraceDeclaration } from '@voiceflow/sdk-runtime';

import type { RuntimeMessage } from '../contexts/RuntimeContext/messages';

export type TraceHandler<T extends Trace.AnyTrace = Trace.AnyTrace> = TraceDeclaration<RuntimeMessage, T>;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/types/turn.ts

import type { SystemResponseProps } from '@/components/SystemResponse';
import type { UserResponseProps } from '@/components/UserResponse';

export enum TurnType {
  USER = 'user',
  SYSTEM = 'system',
}

export interface UserTurnProps extends UserResponseProps {
  id: string;
  type: TurnType.USER;
}

export interface SystemTurnProps extends Omit<SystemResponseProps, 'avatar'> {
  id: string;
  type: TurnType.SYSTEM;
  timestamp: number;
}

export type TurnProps = UserTurnProps | SystemTurnProps;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/types/util.ts

export type StringifiedEnum<T extends string> = T | `${T}`;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/actions.ts

import { BaseRequest } from '@voiceflow/base-types';
import type { RuntimeAction } from '@voiceflow/sdk-runtime';

import { openURLInANewTab } from '@/utils/url';

const hasActions = (action: RuntimeAction): action is BaseRequest.ActionRequest =>
  !!action.payload &&
  typeof action.payload === 'object' &&
  Array.isArray((action.payload as Record<string, unknown>).actions);

export const handleActions = (action: RuntimeAction) => {
  if (hasActions(action)) {
    action.payload?.actions?.forEach((action) => {
      if (BaseRequest.Action.isOpenURLAction(action) && action.payload.url) {
        openURLInANewTab(action.payload.url);
      }
    });
  }
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/assistant.test.ts

import { VoiceflowRuntime } from '@voiceflow/sdk-runtime';
import { createMock } from '@voiceflow/test-common/vitest';
import type { Mock } from 'vitest';
import { describe, expect, it, vi } from 'vitest';

import type { RawAssistantOptions } from '@/dtos/AssistantOptions.dto';
import { DEFAULT_AVATAR } from '@/dtos/AssistantOptions.dto';
import type { ChatConfig } from '@/dtos/ChatConfig.dto';
import { ExtensionType } from '@/dtos/Extension.dto';
import { PRIMARY } from '@/styles';
import { ChatPersistence, ChatPosition } from '@/types';

import { mergeAssistantOptions } from './assistant';

vi.mock('@voiceflow/sdk-runtime', () => ({ VoiceflowRuntime: vi.fn() }));

describe('assistant utils', () => {
  const mockGetPublishing = (): Mock<
    Parameters<VoiceflowRuntime<any>['getPublishing']>,
    ReturnType<VoiceflowRuntime<any>['getPublishing']>
  > => {
    const getPublishing = vi.fn().mockResolvedValue({});

    vi.mocked(VoiceflowRuntime).mockImplementation(() => createMock<VoiceflowRuntime<any>>({ getPublishing }));

    return getPublishing;
  };

  describe('mergeAssistantOptions()', () => {
    const config = {} as ChatConfig;
    const remoteOptions: RawAssistantOptions = {
      title: 'remote',
      color: 'remote',
      image: 'remote',
      avatar: 'remote',
      watermark: false,
      feedback: true,
      description: 'remote',
      position: ChatPosition.LEFT,
      persistence: ChatPersistence.MEMORY,
      launcher: 'remote',
      stylesheet: ['remote'],
      audioInterface: false,
      spacing: {
        side: 100,
        bottom: 100,
      },
      extensions: [{ name: 'remote_extension', type: ExtensionType.EFFECT, match: () => false }],
    };

    it('should fallback to default options when not configured', async () => {
      mockGetPublishing();

      const merged = await mergeAssistantOptions(config, {});

      expect(merged).toEqual({
        title: 'Voiceflow Assistant',
        color: PRIMARY,
        image: DEFAULT_AVATAR,
        avatar: DEFAULT_AVATAR,
        watermark: true,
        feedback: false,
        description: '',
        position: ChatPosition.RIGHT,
        audioInterface: false,
        persistence: ChatPersistence.LOCAL_STORAGE,
        spacing: {
          side: 30,
          bottom: 30,
        },
        extensions: [],
      });
    });

    it('should use remote values pulled from publishing configuration', async () => {
      mockGetPublishing().mockResolvedValue(remoteOptions);

      const merged = await mergeAssistantOptions(config, undefined);

      expect(merged).toEqual({
        ...remoteOptions,
        extensions: [expect.objectContaining({ name: 'remote_extension', type: ExtensionType.EFFECT })],
      });
    });

    it('should prioritize local options over remote options (with some exceptions)', async () => {
      const localOptions: RawAssistantOptions = {
        title: 'local',
        color: 'local',
        image: 'local',
        avatar: 'local',
        description: 'local',
        position: ChatPosition.RIGHT,
        persistence: ChatPersistence.SESSION_STORAGE,
        launcher: 'local',
        stylesheet: ['local'],
        audioInterface: false,
        spacing: {
          side: 150,
          bottom: 150,
        },
        extensions: [{ name: 'local_extension', type: ExtensionType.EFFECT, match: () => false }],

        // setting these locally should have no effect
        watermark: !remoteOptions.watermark,
        feedback: !remoteOptions.feedback,
      };
      mockGetPublishing().mockResolvedValue(remoteOptions);

      const merged = await mergeAssistantOptions(config, localOptions);

      expect(merged).toEqual({
        ...localOptions,
        extensions: [
          expect.objectContaining({ name: 'remote_extension', type: ExtensionType.EFFECT }),
          expect.objectContaining({ name: 'local_extension', type: ExtensionType.EFFECT }),
        ],

        // verify these setting have not changed from what is remote
        watermark: remoteOptions.watermark,
        feedback: remoteOptions.feedback,
      });
    });

    it('should merge spacing from multiple sources', async () => {
      const localOptions: RawAssistantOptions = {
        spacing: { side: 100 },
      };
      mockGetPublishing().mockResolvedValue({ spacing: { bottom: 100 } });

      const merged = await mergeAssistantOptions(config, localOptions);

      expect(merged).toEqual({
        title: 'Voiceflow Assistant',
        color: PRIMARY,
        image: DEFAULT_AVATAR,
        avatar: DEFAULT_AVATAR,
        watermark: true,
        feedback: false,
        description: '',
        position: ChatPosition.RIGHT,
        audioInterface: false,
        persistence: ChatPersistence.LOCAL_STORAGE,
        spacing: {
          side: 100,
          bottom: 100,
        },
        extensions: [],
      });
    });
  });
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/assistant.ts

import { VoiceflowRuntime } from '@voiceflow/sdk-runtime';
import type { PartialDeep } from 'type-fest';

import type { RawAssistantOptions } from '@/dtos/AssistantOptions.dto';
import { AssistantOptions } from '@/dtos/AssistantOptions.dto';
import type { ChatConfig } from '@/dtos/ChatConfig.dto';

export const mergeAssistantOptions = async (
  config: ChatConfig,
  overrides: RawAssistantOptions
): Promise<AssistantOptions> => {
  const { versionID } = config;

  // fetch remote publishing config
  const runtime = new VoiceflowRuntime(config);

  const publishing = await runtime
    .getPublishing<PartialDeep<AssistantOptions>>({ ...(versionID && { versionID }) })
    .catch((error) => {
      console.error(error);
      return null;
    });

  return AssistantOptions.parse({
    ...publishing,
    ...overrides,
    // watermark can not be overridden with local config
    watermark: publishing?.watermark,
    feedback: publishing?.feedback,
    spacing: {
      ...publishing?.spacing,
      ...overrides?.spacing,
    },
    extensions: [...(publishing?.extensions ?? []), ...(overrides?.extensions ?? [])],
  });
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/broadcast.ts

import type { BaseRequest } from '@voiceflow/dtos-interact';

import type { SessionOptions } from '@/types';

export enum BroadcastType {
  SAVE_SESSION = 'voiceflow:save_session',

  INTERACT = 'voiceflow:interact',

  OPEN = 'voiceflow:open',
  CLOSE = 'voiceflow:close',
}

export interface BroadcastMessage {
  type: BroadcastType;
  payload?: unknown;
}

export interface SaveSession extends BroadcastMessage {
  type: BroadcastType.SAVE_SESSION;
  payload: SessionOptions;
}

export interface Interact extends BroadcastMessage {
  type: BroadcastType.INTERACT;
  payload: {
    session: SessionOptions;
    action: BaseRequest;
  };
}

export interface Open extends BroadcastMessage {
  type: BroadcastType.OPEN;
}
export interface Close extends BroadcastMessage {
  type: BroadcastType.CLOSE;
}

export type AnyMessage = SaveSession | Interact | Open | Close;

// send messages so that other scripts can listen to them
// https://docs.voiceflow.com/docs/web-chat-api#events
export const broadcast = (message: AnyMessage) => {
  const encodedMessage = JSON.stringify(message);
  window.postMessage(encodedMessage);
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/chat.ts

export const createPlaceholderMethods = (
  createMessage: (method: string) => string
): Omit<VoiceflowChat, 'load' | 'destroy'> => {
  const noopWarn = (method: string) => (): any => console.warn(createMessage(method));

  return {
    open: noopWarn('open'),
    hide: noopWarn('hide'),
    show: noopWarn('show'),
    close: noopWarn('close'),
    interact: noopWarn('interact'),

    proactive: {
      clear: noopWarn('proactive.clear'),
      push: noopWarn('proactive.push'),
    },
  };
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/controls.tsx

import React, { useState } from 'react';
import type { SetRequired } from 'type-fest';

export interface ControlProps<T = any> {
  /**
   * The value being controlled by the component.
   */
  value: T;

  /**
   * A callback that will be called with new values when the control is updated.
   */
  onValueChange: (value: T) => void;
}

export type ControlValue<Props> = Props extends ControlProps<infer R> ? R : never;

export type ControlledProps<Props extends ControlProps<any>> = Omit<Props, keyof ControlProps> & {
  initialValue?: ControlValue<Props>;
};

export interface ControlledOptions<Props extends ControlProps> {
  defaultValue?: ControlValue<Props>;
  enrichProps?: <T extends Omit<Props, keyof ControlProps>>(
    props: T,
    state: [ControlValue<Props>, (value: ControlValue<Props>) => void]
  ) => T;
}

export const createControlled: {
  <Props extends ControlProps>(
    Component: React.FC<Props>,
    options: SetRequired<ControlledOptions<Props>, 'defaultValue'>
  ): React.FC<ControlledProps<Props>>;
  <Props extends ControlProps>(
    Component: React.FC<Props>,
    options?: ControlledOptions<Props>
  ): React.FC<SetRequired<ControlledProps<Props>, 'initialValue'>>;
} =
  (Component: React.FC<ControlProps<any>>, options?: ControlledOptions<ControlProps<any>>) =>
  ({ initialValue, ...props }: ControlledProps<ControlProps<any>>) => {
    const stateAPI = useState<ControlProps<any>>((initialValue ?? options?.defaultValue)!);
    const enrichedProps = options?.enrichProps?.(props, stateAPI) ?? props;

    const [value, setValue] = stateAPI;

    return <Component {...enrichedProps} value={value} onValueChange={setValue} />;
  };


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/functional.ts

export const chain =
  <Args extends any[]>(...fns: Array<((...args: Args) => void) | undefined>) =>
  (...args: Args) =>
    fns.forEach((fn) => fn?.(...args));

// eslint-disable-next-line no-empty-function
export const noop = () => {};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/session.ts

import cuid from 'cuid';

import type { SessionOptions } from '@/types';
import { ChatPersistence } from '@/types';

import { broadcast, BroadcastType } from './broadcast';

const VOICEFLOW_SESSION_KEY = 'voiceflow-session';

const getSessionKey = (projectID: string) => `${VOICEFLOW_SESSION_KEY}-${projectID}`;

const getStorageSession = (storage: Storage, projectID: string): SessionOptions | null => {
  try {
    return JSON.parse(storage.getItem(getSessionKey(projectID))!);
  } catch {
    return null;
  }
};

const setStorageSession = (storage: Storage, projectID: string, options: SessionOptions) => {
  storage.setItem(getSessionKey(projectID), JSON.stringify(options));

  return options;
};

//  we can't use function default param `userID = cuid()`, cause it'll break sessions for anonymous users (when the userID is not provided by app)
const resolveSession = (storage: Storage, projectID: string, userID?: string) => {
  const session = getStorageSession(storage, projectID);

  if (!session || (userID && session.userID !== userID)) {
    return setStorageSession(storage, projectID, { userID: userID || cuid() });
  }

  return session;
};

//  we can't use function default param `userID = cuid()`, cause it'll break sessions for anonymous users (when the userID is not provided by app)
export const getSession = (persistence: ChatPersistence, projectID: string, userID?: string): SessionOptions => {
  switch (persistence) {
    case ChatPersistence.MEMORY:
      return { userID: userID || cuid() };
    case ChatPersistence.LOCAL_STORAGE:
      return resolveSession(localStorage, projectID, userID);
    case ChatPersistence.SESSION_STORAGE:
    default:
      return resolveSession(sessionStorage, projectID, userID);
  }
};

export const saveSession = (persistence: ChatPersistence, projectID: string, session: SessionOptions): void => {
  broadcast({ type: BroadcastType.SAVE_SESSION, payload: session });

  if (persistence === ChatPersistence.LOCAL_STORAGE) {
    setStorageSession(localStorage, projectID, session);
  } else if (persistence === ChatPersistence.SESSION_STORAGE) {
    setStorageSession(sessionStorage, projectID, session);
  }

  if (persistence !== ChatPersistence.LOCAL_STORAGE) {
    localStorage.removeItem(getSessionKey(projectID));
  }
  if (persistence !== ChatPersistence.SESSION_STORAGE) {
    sessionStorage.removeItem(getSessionKey(projectID));
  }
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/stylesheet.ts

import { useEffect, useState } from 'react';

import type { AssistantOptions } from '@/dtos/AssistantOptions.dto';

// used to add stylesheets dynamically, resolves when loaded
export const addStyleSheetURL = async (url: string, root: Node) => {
  const link = document.createElement('link');
  const load = new Promise((resolve, reject) => {
    link.onload = resolve;
    link.onerror = reject;
  });

  link.rel = 'stylesheet';
  link.href = url;
  root.appendChild(link);

  await load;
};

// do not load until stylesheet is resolved
export const useResolveAssistantStyleSheet = (assistant?: AssistantOptions, shadowRoot?: ShadowRoot): boolean => {
  const [isStyleSheetResolved, setStyleSheetResolved] = useState(false);

  useEffect(() => {
    if (!assistant || isStyleSheetResolved) return;

    if (!assistant.stylesheet) {
      setStyleSheetResolved(true);
      return;
    }

    const stylesheet = Array.isArray(assistant.stylesheet) ? assistant.stylesheet[0] : assistant.stylesheet;

    // inject stylesheet url
    (async () => {
      await addStyleSheetURL(stylesheet, shadowRoot ?? document.head).catch((error) => {
        console.error(`failed to load stylesheet: ${assistant.stylesheet}`);
        console.error(error);
      });
      setStyleSheetResolved(true);
    })();
  }, [assistant]);

  return isStyleSheetResolved;
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/url.ts

export const LINK_ABOUT_ONLY_REGEX = /^about:[\w#%+.:=@~-]{2,256}\b([\w#%&+./:=?@~-]*)$/;
export const LINK_BITCOIN_ONLY_REGEX = /^bitcoin:[\dA-Za-z]{26,35}([\w#%&+./:=?@~-]*)$/;
export const LINK_CALLTO_ONLY_REGEX = /^callto:[+\d-\s()]+$/;
export const LINK_TEL_ONLY_REGEX = /^tel:[+\d-\s()]+$/;
export const LINK_SMS_ONLY_REGEX = /^sms:[+\d-\s()]+$/;
export const LINK_MAILTO_ONLY_REGEX = /^mailto:([^\s?]+)\b([\w#%&+./:=?@~-]*)$/;
export const LINK_IM_ONLY_REGEX = /^im:([^\s?]+)\b([\w#%&+./:=?@~-]*)$/;
export const LINK_FACETIME_ONLY_REGEX = /^facetime(-(audio|group))?:([^\s?]+|([+\d-()]+))$/;
export const LINK_SKYPE_ONLY_REGEX = /^skype:(\S+)\b$/;
export const LINK_WEBCALL_ONLY_REGEX = /^webcal:(\S+)\b$/;

export const STRICT_LINKS_REGEXS = [
  LINK_ABOUT_ONLY_REGEX,
  LINK_BITCOIN_ONLY_REGEX,
  LINK_CALLTO_ONLY_REGEX,
  LINK_TEL_ONLY_REGEX,
  LINK_SMS_ONLY_REGEX,
  LINK_MAILTO_ONLY_REGEX,
  LINK_IM_ONLY_REGEX,
  LINK_FACETIME_ONLY_REGEX,
  LINK_SKYPE_ONLY_REGEX,
  LINK_WEBCALL_ONLY_REGEX,
];

export const isAnyStrictLink = (str: string): boolean => !!STRICT_LINKS_REGEXS.some((regexp) => str.match(regexp));

export const getValidHref = (href: string): string =>
  href.startsWith('//') || href.includes('://') || isAnyStrictLink(href) ? href : `//${href}`;

/**
 * opens url in  anew tab, noopener and noreferrer is set to true by default
 */
export const openURLInANewTab = (url: string, features = 'noopener=true,noreferrer=true'): void =>
  window.open(getValidHref(url), '_blank', features)?.focus();


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/utils/variants.tsx

import React from 'react';

export type Stringify<T> = T extends string | number ? T | `${T}` : T;

export type VariantProps<Variants extends Record<string, React.FC<any>>, Default extends keyof Variants = never> = {
  [K in keyof Variants]: (K extends Default ? { variant?: Stringify<K> } : { variant: Stringify<K> }) &
    React.ComponentProps<Variants[K]>;
}[keyof Variants];

export const bindVariants = <Variants extends Record<string, React.FC<any>>, Default extends keyof Variants = never>(
  variants: Variants,
  defaultVariant?: Default
) => {
  return React.forwardRef<HTMLElement, VariantProps<Variants, Default>>(
    ({ variant = defaultVariant, ...props }, ref) => {
      const Variant = variants[variant];

      if (!Variant) return null;

      return <Variant {...props} ref={ref} />;
    }
  );
};


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/views/ChatEmbed/index.tsx

import { useContext, useEffect } from 'react';

import { RuntimeStateAPIContext } from '@/contexts';
import { useChatAPI, useTheme } from '@/hooks';
import { useResolveAssistantStyleSheet } from '@/utils/stylesheet';

import ChatWindow from '../ChatWindow';

interface ChatEmbedProps extends React.PropsWithChildren {
  shadowRoot: ShadowRoot;
  chatAPI: VoiceflowChat | undefined;
  ready?: () => void;
}

const ChatEmbed: React.FC<ChatEmbedProps> = ({ shadowRoot, chatAPI, ready }) => {
  const { assistant, interact, open } = useContext(RuntimeStateAPIContext);
  const theme = useTheme(assistant);

  const isStyleSheetResolved = useResolveAssistantStyleSheet(assistant, shadowRoot);

  useChatAPI(
    chatAPI,
    () => {
      console.info('Methods open, close, hide, show, proactive.clear, proactive.push have no effect in this mode.');

      return { interact };
    },
    ready
  );

  useEffect(() => {
    // "open" the embedded chat window to trigger launch
    open();
  }, []);

  if (!isStyleSheetResolved) return null;
  return <ChatWindow className={theme} />;
};

export default ChatEmbed;


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/views/ChatWidget/index.tsx

import type { Trace } from '@voiceflow/base-types';
import React, { useContext, useMemo, useState } from 'react';

import Launcher from '@/components/Launcher';
import Proactive from '@/components/Proactive';
import { RuntimeStateAPIContext, RuntimeStateContext } from '@/contexts';
import { useChatAPI, useTheme } from '@/hooks';
import { useResolveAssistantStyleSheet } from '@/utils/stylesheet';
import ChatWindow from '@/views/ChatWindow';

import { ChatContainer, Container, LauncherContainer } from './styled';

interface ChatWidgetProps extends React.PropsWithChildren {
  shadowRoot?: ShadowRoot;
  chatAPI: VoiceflowChat | undefined;
  ready?: () => void;
}

const ChatWidget: React.FC<ChatWidgetProps> = ({ shadowRoot, chatAPI, ready }) => {
  const { assistant, open, close, interact } = useContext(RuntimeStateAPIContext);
  const { isOpen } = useContext(RuntimeStateContext);

  /** initialization */
  const [isHidden, setHidden] = useState(false);
  const [proactiveMessages, setProactiveMessages] = useState<Trace.AnyTrace[]>([]);
  const isMobile = useMemo(() => window.matchMedia('(max-width: 768px)').matches, []);

  const theme = useTheme(assistant);

  useChatAPI(
    chatAPI,
    () => ({
      open,
      close,
      hide: () => setHidden(true),
      show: () => setHidden(false),
      interact,
      proactive: {
        clear: () => setProactiveMessages([]),
        push: (...messages: Trace.AnyTrace[]) => setProactiveMessages((prev) => [...prev, ...messages]),
      },
    }),
    ready
  );

  const side = assistant.position;
  const position = { bottom: assistant.spacing.bottom, [side]: assistant.spacing.side };

  const isStyleSheetResolved = useResolveAssistantStyleSheet(assistant, shadowRoot);

  if (!isStyleSheetResolved) return null;

  return (
    <Container withChat={isOpen} isHidden={isHidden} className={theme}>
      <LauncherContainer style={position}>
        <Proactive side={side} messages={proactiveMessages} />
        <Launcher onClick={open} image={assistant.launcher} />
      </LauncherContainer>
      <ChatContainer style={isMobile ? {} : position}>
        <ChatWindow />
      </ChatContainer>
    </Container>
  );
};

export default Object.assign(ChatWidget, {
  Launcher,
  Container,
  ChatContainer,
  LauncherContainer,
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/views/ChatWidget/styled.ts

import { ClassName } from '@/constants';
import { tagFactory } from '@/hocs';
import type { CSS } from '@/styles';
import { styled } from '@/styles';

const CHAT_WIDTH = 380;
const MAX_CHAT_HEIGHT = 800;

const tag = tagFactory(ClassName.WIDGET);

export const ChatContainer = styled(tag('div', 'chat'), {
  width: CHAT_WIDTH,
  overflow: 'hidden',
  borderRadius: '$2',
  boxShadow: '0 2px 48px rgba(19,33,68,0.16), 0 0 0 1px $shadow4',
  height: '90%',
  maxHeight: MAX_CHAT_HEIGHT,

  '@mobile': {
    position: 'fixed',
    height: 'unset',
    maxHeight: 'unset',
    width: 'unset',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    borderRadius: 0,
    boxShadow: 'none',
  },
});

export const LauncherContainer = styled(tag('div', 'launcher'), {});

const animateInStyles: CSS = {
  opacity: 1,
  pointerEvents: 'auto',
  transform: 'translateY(0%)',
  transition: 'transform 300ms cubic-bezier(0, 0.95, 0.1, 1), opacity 150ms linear',
};

const animateOutStyles: CSS = {
  opacity: 0,
  pointerEvents: 'none',
  transform: 'translateY(100%)',
  transition: 'transform 300ms cubic-bezier(0.85, 0, 0.6, 1), opacity 150ms linear',
};

export const Container = styled(tag('div'), {
  position: 'fixed',
  inset: 0,
  '-webkit-font-smoothing': 'antialiased',
  '-moz-osx-font-smoothing': 'grayscale',
  pointerEvents: 'none',
  zIndex: 10000,

  [`
    & > ${LauncherContainer},
    & > ${ChatContainer}
  `]: {
    position: 'absolute',
  },

  variants: {
    withChat: {
      true: {
        [`& > ${ChatContainer}`]: {
          ...animateInStyles,
        },
        [`& > ${LauncherContainer}`]: {
          ...animateOutStyles,
        },
      },
      false: {
        [`& > ${ChatContainer}`]: {
          ...animateOutStyles,
        },
        [`& > ${LauncherContainer}`]: {
          ...animateInStyles,
        },
      },
    },
    isHidden: {
      true: {
        display: 'none',
      },
    },
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/views/ChatWindow/index.tsx

import '../../styles.css';

import React, { useCallback, useContext } from 'react';
import * as R from 'remeda';
import { match } from 'ts-pattern';

import { Chat, SystemResponse, UserResponse } from '@/components';
import { RuntimeStateAPIContext, RuntimeStateContext } from '@/contexts/RuntimeContext';
import type { FeedbackName } from '@/contexts/RuntimeContext/useRuntimeAPI';
import type { UserTurnProps } from '@/types';
import { SessionStatus, TurnType } from '@/types';

import { ChatWindowContainer } from './styled';

export interface ChatWindowProps {
  className?: string;
}

const ChatWindow: React.FC<ChatWindowProps> = ({ className }) => {
  const runtime = useContext(RuntimeStateAPIContext);
  const state = useContext(RuntimeStateContext);
  const { assistant, config } = runtime;

  // emitters
  const closeAndEnd = useCallback((): void => {
    runtime.setStatus(SessionStatus.ENDED);
    runtime.close();
  }, []);

  const getPreviousUserTurn = useCallback(
    (turnIndex: number): UserTurnProps | null => {
      const turn = state.session.turns[turnIndex - 1];
      return turn?.type === TurnType.USER ? turn : null;
    },
    [state.session.turns]
  );

  return (
    <ChatWindowContainer className={className}>
      <Chat
        title={assistant.title}
        description={assistant.description}
        image={assistant.image}
        avatar={assistant.avatar}
        withWatermark={assistant.watermark}
        startTime={state.session.startTime}
        hasEnded={runtime.isStatus(SessionStatus.ENDED)}
        isLoading={runtime.isStatus(SessionStatus.IDLE) && state.session.turns.length === 0 && config.autostart}
        onStart={runtime.launch}
        onEnd={closeAndEnd}
        onSend={runtime.reply}
        onMinimize={runtime.close}
        audioInterface={assistant.audioInterface}
      >
        {state.session.turns.map((turn, turnIndex) =>
          match(turn)
            .with({ type: TurnType.USER }, ({ id, ...props }) => <UserResponse {...R.omit(props, ['type'])} key={id} />)
            .with({ type: TurnType.SYSTEM }, ({ id, ...props }) => (
              <SystemResponse
                key={id}
                {...R.omit(props, ['type'])}
                feedback={
                  assistant.feedback
                    ? {
                        onClick: (feedback: FeedbackName) => {
                          runtime.feedback(feedback, props.messages, getPreviousUserTurn(turnIndex));
                        },
                      }
                    : undefined
                }
                avatar={assistant.avatar}
                isLast={turnIndex === state.session.turns.length - 1}
              />
            ))
            .exhaustive()
        )}
        {state.indicator && <SystemResponse.Indicator avatar={assistant.avatar} />}
      </Chat>
    </ChatWindowContainer>
  );
};

export default Object.assign(ChatWindow, { Container: ChatWindowContainer });


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/views/ChatWindow/styled.ts

import Chat from '@/components/Chat';
import { styled } from '@/styles';

export const ChatWindowContainer = styled('div', {
  height: '100%',

  [`& ${Chat.Container}`]: {
    height: '100%',
  },
});


// File: /Users/yannickromainsegaar/react-chat/packages/react-chat/src/views/index.ts

export { default as ChatEmbed } from './ChatEmbed';
export { default as ChatWidget } from './ChatWidget';
export { default as ChatWindow } from './ChatWindow';
